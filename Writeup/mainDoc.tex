\documentclass{article}

%Document Information
\title{GCE Computer Science Component 3}
\author{Edward Robert Karol Demkowicz-Duffy}

%Define page margins with geometry
\usepackage[a4paper, total={6.25in, 9in}]{geometry}

%Remove footnote ruling
\renewcommand*\footnoterule{}

%Import package for forcing image locations
\usepackage{float}

%Import package for images and set graphics path to /images
\usepackage{graphicx}
\graphicspath{{./images/}}

%Import package for managing sections, configure to add a new page every section
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}
\newcommand{\subsectionbreak}{\clearpage}

%Import package for handling enumeration and configure it
\usepackage{enumitem}
\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

%Import package for code
\usepackage{listings}
\lstset{defaultdialect=[Sharp]C}
\usepackage{xcolor}
%Configure code syntax highlighting
\definecolor{codenormal}{rgb}{0.862, 0.862, 0.862}
\definecolor{codekeyword}{rgb}{0.337, 0.603, 0.839}
\definecolor{codecomment}{rgb}{0.341, 0.650, 0.290}
\definecolor{codestring}{rgb}{0.839, 0.615, 0.521}
\definecolor{backcolour}{rgb}{0.117, 0.117, 0.117}
%Define pseudocode
\lstdefinelanguage{psuedocode}
{
  %Keywords
  morekeywords={
      global,
      str,
      int,
      float,
      list,
      print,
      input,
      for,
      to,
      next,
      do,
      until,
      AND,
      OR,
      NOT,
      if,
      then,
      elseif,
      endif,
      switch,
      case,
      default,
      endswitch,
      function,
      return,
      endfunction,
      procedure,
      endprocedure,
      array
  },
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{//}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}
%Define style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codecomment},
    keywordstyle=\color{codekeyword},
    stringstyle=\color{codestring},
    basicstyle=\footnotesize\color{codenormal}\linespread{1.15},
    numberstyle=\color{black},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
%Apply style
\lstset{style=mystyle}

%Import package for drawing flowcharts
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
%Define styles for the flowcharts
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1.5cm,text centered, text width=4cm, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1.5cm, text centered, text width=4cm, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1.5cm, text centered, text width=4cm, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, text width=4cm, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}
    \pagenumbering{gobble}
    \maketitle
    
    \tableofcontents
    \pagenumbering{arabic}
    
    %Set the table of contents depth to only show sections and subsections
    %\addtocontents{toc}{\setcounter{tocdepth}{2}}
    \section{Analysis}
    \subsection{Problem Description}
    \paragraph{•}
    My client is a personal friend and the owner of a business that is based around the sale of novelty clocks and coasters manufactured from or based on vinyl records. 
    They buy (often) second hand vinyl records from various sources, cut out the album art in the middle and use that to mount a clock mechanism on, then package it in it’s original sleeve modified to become a box as a clock to be hung or place on a surface. 
    They also manufacture sets of coasters which are artificially manufactured to appear as vinyl records, sold in sets of matching bands or contemporary albums. 
    Their present sales solution is in three parts:
    \begin{itemize}
    \item Online sales through third party storefronts Etsy and eBay
    \item Face-to-face sales at the client’s stall at the regular Manchester Christmas markets
    \item Other face-to-face sales at any other events the client or their employees may wish to attend, irregularly
    \end{itemize}
    This solution is inconvenient for multiple reasons. 
    The two storefronts provide quite different experiences and tools for people wanting to sell their products on their platforms and thus my client often finds it difficult to deduce trends and critical values like net profits in their overall online sales. 
    Sales at the Christmas markets are difficult to keep track of as the square they are held in get crowded and the client/their employees frequently lose track of sales, which can be found at the end of the day by examining existing records, money gained and remaining stock; but is still an obstacle to clear analysis of the client’s sales. 
    Stalls at other events are usually set up at short notice, and similar logistical problems tend to arise as with the Christmas markets, but with less pre planning time and available information they also tend to be more difficult to solve. 
    \paragraph{•}
    The client would like a web app which provides a quality sales experience to customers, and powerful management tools and information for employees. 
    It must have an online storefront, a (modifiable) storage method to track products and all their related information (most importantly stock and price) and sales of said products. 
    Users should have to register to make purchases. 
    Employees should be to view and modify products. 
    There should be easy tools that specialize in managing stock and sales both at the beginning and the end of a day when the client sells their products at an event, be it unexpected or scheduled. 
    The client also specifically requests that employees be able to view statistics and basic analysis of sales displayed in an easy-to-understand way. 
    Employees with special permission should also be able to modify the accounts of both customers and other employees and delete or add products to the program’s storage. 
    Furthermore, the website must be secure, with both customers’ and employees’ data appropriately protected and must appear professional and easy to comprehend.
    
    \subsection{Stakeholders}
    \paragraph{•}
    Stakeholders are identified here as being people who must use, or will be directly affected by, the program. 
    There are three primary stakeholders, who must be born in mind during the creation of the web app:
    \paragraph{Customers}
    These are the most important stakeholders as they as the client’s source of income. 
    They must have the easiest and most convenient experience possible, to retain their attention on the products the client wishes to sell to them. 
    They will benefit from the project by having a quick and easy way to exchange money for goods they wish to buy. 
    As such, the interface they use should be carefully and logically laid out, with no unneeded features or artefacts on it. 
    Products should be described clearly and concisely so the customers know exactly what they are buying and all other information relevant to it.
    \paragraph{Staff}
    These are the people employed by the client who manage their stock and make sales in person. 
    Their side of the web app will be used for swift and easy viewing of stock and statistics – they may also need to modify stock data. 
    Therefore it must provide the quickest and most powerful ways to manage current stock and sales at physical stalls, and helpful processed sales data.
    \paragraph{Administrators} 
    These are senior employees who have all the responsibilities of other employees but have more power over the company’s assets. 
    They have the same requirements as regular employees, but also need to be able to view the data of customers and ordinary employees, be able to add whole new products to the set (and delete existing ones), be able to change the passwords of and delete accounts (be they employee or customer) and be able to view technical data such as logs.
    
    \subsection{Solving with Computational Methods}
    \paragraph{•}
    The client requires a centralised service for distributing their products en masse to customers who may be international – a website or web app is perfect for this purpose as it can be accessed anywhere, can be easily translated, and requires little to no uncommon knowledge to use and access. 
    It can be accessed from many places at once and run in parallel in all these places without compromising at all in any.
    \paragraph{•}
    The client requires a service that will supply their company with processed data that will help them analyse their sales strategies and improve them. 
    Computers excel at this as it is a repetitive numerical task which can be completed by a processor much faster than a human analyst. 
    In addition to this, computers can scale easily to very large amounts of data, whereas other methods (aforementioned analyst) would likely struggle to cope in comparison.
    \paragraph{•}
    The client requires a method for organising all their stock in a central location, with the ability for it to be accessed and changed from anywhere at any time. 
    An always-on, internet-connected data source is an exceptional solution for this problem because besides matching all the required criteria since it can be accessed from anywhere by anyone with the appropriate credentials, it can add useful functionality to them by logging all information transfers and enforcing logical rules like relationships between data and correct formatting. 
    The same data source can store information about both the customers and employees who use it for increased availability of data. 
    This ties in with the previous requirement as all the data needing to be processed being stored in one (digital) location is extremely helpful for any computerised process trying to access it, keeping time taken to do that processing short.
    \paragraph{•}
    Another advantage of the service being hosted online is that issues that may arise with the software are quick and easy to patch out as the patch can be deployed immediately to the only host with little to no downtime, meaning the service remains almost completely uninterrupted.
    
    \subsection{Research}
    \subsubsection{The Client's Current Solution}
    \paragraph{•}
    As mentioned in the problem description, the client employs eBay and Etsy to sell their products online; however as I have covered these examples below I will focus on the physical sales element in this section.
    \paragraph{Advantages}
    There are several advantages to this method of selling, most of which are related to the fact that the customer can talk to an employee in person and that they can view the product they wish to buy first hand.
    \paragraph{•}
    The customer can examine the product on site, and view properties of it that they may not be able to judge through a website like size, weight and "true" colour.
    This increases the probability that the customer will make a purchase considerably, and so would be desirable to try to compensate for in the we application - the methods this could be accomplished through are essentially to ensure the product is represented on it's "page" as accurately and fully as possible.
    Dimensions should be included along with multiple images of the product from different angles and in different lighting conditions.
    \paragraph{•}
    The customer can also talk to the employee for an extended period of time if they wish, which gives the employee the opportunity to convince them to purchase the product and to further enhance their image in the eyes of the customer (i.e. beyond what the customer has viewed of the array of products and the stall itself).
    Again, it is hard to provide a comparable service on a website to this.
    One solution would be to include a live text chat interface on the web application.
    This would require constant employee presence which is not feasible for my client as their company is not large enough or well-known enough to warrant having a team of support staff available.
    Another method would be to provide a phone number on the website and encourage people to call it if they have enquiries so as to reduce the requirements on the hosting machine and potentially the number of people needed to answer, but this would still suffer from the same problems as the first proposal (albeit less so).
    \paragraph{Disadvantages}
    Employees can only bring and display so much stock to a physical event, which means the choice and availability customers see is severely stunted.
    A web application would inherently solve this issue because the entire inventory is displayed simultaneously so this does not need to be considered.
    \paragraph{•}
    Furthermore, the inventory the client takes with them is vulnerable to theft and damage while it is on display at the event.
    This is another problem that is solved by developing a web application as a replacement because no stock is "exposed" until it has been sold to a customer.
    \subsubsection{Existing Successful Examples}
    \paragraph{•}
    This type of software is commonly used in ordinary life today.
    Multiple excellent examples already exist, some of which the client already utilizes.
    Three prominent extremely successful public examples are listed below:
    \begin{itemize}
    \item Amazon
    \item eBay
    \item Etsy
    \end{itemize}
    \paragraph{Amazon}
    This site is an enormous online marketplace which allows any verified entity to buy or sell goods there.
    It features extensive methods for displaying information about the goods listed on it, including images, hand written descriptions, multiple variants, stock amounts, delivery information (cost, areas available to deliver to) and in depth public user reviews.
    It also contains algorithms designed to promote other products to the user, displayed in the form of recommendations, usually labelled "people who bought this bought" or other such categories.
    I would guess that these are generated from the logged-in user's purchase history and viewing history by categorising all products on the website, then suggesting the most popular products in the categories the user views and purchases from the most.
    This is an excellent method to retain user attention and encourage users to stay on the site and spend more money.
    The feature would be excellent to incorporate into my own application, however it could prove algorithmically quite complex to implement.
    \paragraph{•}
    The site allows users to store payment information and delivery addresses for ease of use in future transactions - another great way to make user's experience much easier and quicker, which will in turn increase the chances of them making more purchases on the site.
    The site stores customer's order history in depth with information pertaining to when they were ordered, how much was paid, when they were delivered and even who to.
    In addition, they provide live tracking of orders which are in the process of being delivered.
    \paragraph{•}
    Amazon also displays advertisements for currently running sales, new products and even new features.
    This draws the attention of users to popular products which they are more likely to buy.
    More so, the efficiency of shopping (i.e. the amount of time it takes to locate a specific product) is much improved by a large array of searching, sorting and filtering options when browsing available goods.
    Users can sort by price, name and search relevance to name but a few, and can search product names across the whole site or within specified categories.
    
    \paragraph{eBay}
    This is a site similar to Amazon which allows buyers and sellers to make transactions in exchange for goods and services online.
    In contrast to Amazon, however, eBay facilitates time-limited auctions to be hosted which buyers can place bids on during a set time period, where the product will be sold to the highest bidder who will pay their named price to the seller.
    The user interface surrounding this feature is designed fantastically to make it as simple and easy as possible for customers to place bids - it shows them the starting price, the time remaining (live) and the current highest bid.
    It makes placing a bid as easy as entering a value in a text box and pressing a button with extremely low latency, so that competitive bidding can occur fairly towards the end of the time period which I frequently observed to drive the final price much higher within a small time frame.
    This means sellers can create highly competitive environments for optimum profit, something I thought my client would appreciate greatly, but upon contacting them they informed me they were not interested in auctioning their products.
    Still, there are definitely notes to be taken here as the design philosophies of the highly intuitive GUI displayed on the auction page can be applied well to the selling pages of my own project.
    \\
    eBay offers many of the features Amazon does, namely the recommendations of other products, all the delivery related features and the saving of information related to those deliveries (addresses and payment methods).
    \paragraph{Etsy}
    This is another online marketplace with a similar goal to the aforementioned two.
    It's distinguishing feature is that it allows sellers to design and construct their own personalised pages to display their products and their information, referred to as their "shop".
    This is a powerful function as it allows sellers to present themselves as they wish to prospective buyers, be it using particular colour palettes or shape designs, this sets the "attitude" of the seller and creates a "mood" relating to them.
    While this feature on it's own is not especially relevant to my client's needs as they wan to sell only as one entity in their own location, the core concept of presenting an impression to the user is a powerful way to get a consistent "feel" across the site which fits with my client's intended public image.
    \subsubsection{Conclusion}
    Key features shared by all the successful examples are:
    \begin{itemize}
    \item Algorithmically-generated recommendations for the customer based on their order and viewing history.
    While a full implementation of this may prove to be out of the scope of my project, it is clearly a useful feature to implement that may well increase the chance of purchases being made by users.
    Alternatives could be to show users "buy it again" or "next in the set" options.
    \item Convenience-based features.
    All the websites I examined were obviously designed to make the user experience as slick as possible.
    This is very helpful for the seller and website because it encourages the user to spend more time browsing and buying due to the whole process being easier.
    As such, it should be an important success criterion that the user experience is as "smooth" as possible to promote the most time spent on the website.
    \item Comprehensive searching and filtering tools.
    These are designed to assist customers finding the product that suits their needs.
    The products which will be displayed on my project will be more similar than those present on the websites examined, but the idea of searching through them can be carried over still.
    The web app I will build should offer similar functionality if it wants users to locate products as swiftly as possible.
    \item Information-laden lists of products.
    These worked exceptionally well when used in conjunction with the above tools.
    Each product is represented in short with crucial information clearly available in a small space, which further assists in finding the desired products.
    \item Plentiful information related to the item the user is viewing.
    Each website has an individual page for each item the user views containing a plethora of data that they may want to find about the product.
    All three website showed a "slide show" of photographs or other images of the product they were viewing, and allowed them to zoom in and examine them.
    Descriptions written by the sellers featured markdown formatting to allow text effects such as bolding, italics, links and underlining which help express information the seller writes more effectively and strikingly.
    Stock and prices are shown in depth, with exact numbers of stock left and the delivery costs displayed clearly and prominently in the foreground of the page's design.
    These would all be good ideas to follow from.
    \item Storage and easy access of the user's data.
    This includes past payments and addresses so the user doesn't have to go and retrieve their cards when making a purchase, which in turn keeps them browsing longer and improves their experience making transactions.
    The sites also store all a user's past orders and display them in a concise way upon request, with money spent, which product, the amount of that product and the date the order was placed all very visible.
    This is a feature which I can and plan to implement in my own website very effectively, as I already planned to store extended data about any orders made within the program.
    \end{itemize}
    Appearance appears to play a key role in usability too - all the websites I examined had consistent colour palettes and designs across all pages which gave a distinct impression of professionalism.
    \subsubsection{Laws}
    There are several laws pertaining to data hosted online.
    Since the service I intend to construct will store sensitive personal information, the Data Protection Act 1998 dictates that the service provider is responsible for any damage or theft of that data.
    My solution must be secure enough that the client can be confident their user's data is safe from people who shouldn't see it as they would be held liable should it be stolen.
    \subsection{Software and Hardware Requirements}
    \paragraph{•}
    As this software will be interacted with in different ways to how it is run at it’s actual location, I have included two sets of hardware requirements; one for the end user (be they employee or customer) and one for the server hosting the software:
    
    \subsubsection{Client Computers}
    \begin{itemize}
    \item The latest version of a modern browser. 
    I recommend Google Chrome, Microsoft Edge, Mozilla Firefox, Opera or Safari.
    \item A computer which can run that browser. For reference, I have taken the requirements\footnote{https://www.mozilla.org/en-US/firefox/58.0.2/system-requirements/} for Mozilla Firefox, which is regarded as an industry standard:
    \begin{itemize}
    \item Pentium 4 or newer processor that supports SSE2
    \item 512MB of RAM / 2GB of RAM for the 64-bit 
    \item 200MB of hard drive space
    \end{itemize}
    \item An internet connection with download speed equal to or exceeding 5MB/s (megabits per second)
    \end{itemize}
    
    \subsubsection{Host Computer}
    \begin{itemize}
    \item At least 5GB of available secondary storage with a high read/write rate
    \item A modern high-performance server processor with 4 or more cores clocked at more than 3GHz
    \item At least 16GB of RAM
    \item An internet connection with download and upload speeds equal to or exceeding 1GB/s (gigabits per second)
    \end{itemize}
    
    \subsection{Success Criteria}
    \begin{enumerate}
    \item Write a web application that holds information about orders, customers, products and employees. 
    \item The web application must show users the appropriate data for their role in using the program; products data to customers, managerial data to employees, all data to administrators.
    \item The web application must allow customers to create their own credential combinations which they must use to identify themselves when interacting with the web application.
    \item The web application must allow customers to select products they would like to buy and purchase them. 
    Furthermore, it must provide them adequate data to make this decision on. 
    \item The web application must allow employees to view and edit information stored in the application which they are permitted to. They may view:
    \begin{itemize}
    \item All data related to all products
    \item All data related to placed orders
    \item The usernames of all registered customers
    \end{itemize}
    They may edit: 
    \begin{itemize}
    \item The stock value of all products
    \item The passwords of registered customers
    \end{itemize}
    \item The web application must allow administrators to view and edit information stored in the application which is likely to be necessary. They may view:
    \begin{itemize}
    \item All data related to all products
    \item All data related to placed orders
    \item The usernames and personal data of all registered customers
    \item The usernames and personal data of all registered employees
    \item The background logs kept by the application
    \end{itemize}
    They may add:
    \begin{itemize}
    \item Employee accounts
    \item Products
    \end{itemize}
    They may delete:
    \begin{itemize}
    \item Customer accounts
    \item Employee accounts
    \item Products
    \end{itemize}
    \item The web application should show employees helpful data on sales, including but not limited to:
    \begin{itemize}
    \item Sales per week
    \item Sales per month
    \item Sales per year
    \item Sales per customer
    \end{itemize}
    It should also be able to show not just sales volume but total income for all of the above. It should display these data in a graphical visualisation which allows quick and easy interpretation of the data.
    \item The web application should provide a facility for helping employees manage sales in person.
    This facility should be able to track what products the employee has taken with them and "reserve" them from the main inventory.
    It should be able to record what was sold at the end of the event as specially marked orders, and return all unsold "reserved" items to the main inventory.
    \item All the above should be accomplished such that it is hard enough for outside hostile elements to access sensitive data to allow the client to be confident that the service won't breach the Data Protection Act 1998.
    \end{enumerate}
    
    \section{Design}
    \subsection{Problem Decomposition}
    \paragraph{•}
    This problem must be approached with computation in mind if I am to succeed.
    \paragraph{•}
    I will begin by abstractifying the components of the problem while sticking to my success criteria to keep my goals in sight.
    For this I should focus on compartmentalising the key individual challenges of the project, i.e. login system, data storage method e.t.c.
    As I do this, I will record a plan of the project either on paper or digitally which lays out the requirements of each section and the implementation methods I intend to use.
    The plan should include a list of pages and background processes that the application needs to run.
    \paragraph{•}
    Once I firmly believe my plan is suitable to the problem, I will begin to think about the appearance of the web application.
    I will prototype several sketches for the different pages that I think are appropriate, consult the client with them, use their feedback to improve some of them and show the client again.
    I can repeat this process until we reach a prototype me and the client are both satisfied with.
    When I have a final prototype, I will experiment with different core rules for all pages to follow based on that prototype - these is important because it retains a consistent look throughout the application, giving the user a smoother and more comfortable experience when interacting with it.
    \paragraph{•}
    Having finalised these rules (which will likely be implemented in Cascading Style Sheets files), I shall move onto selecting the devices and methods to employ to develop the application in.
    Most prominently I need to choose a programming language or framework and a method for mass data storage.
    After this, I will progress to actually developing the application using the devices I have chosen.
    I should start with writing the central functions which many other processes or functions rely on first, like the handling of the products and the program's interaction with whatever data source I select, constantly referring to my plan to ensure I am conforming to it as well as adjusting it to compensate for any problems I may have to solve during development.
    Once these are complete, I can move on to writing the code for each of the pages, beginning with the most vital first (probably the login page).
    \paragraph{•}
    At this point it would be wise to present the current working build to the client to gain their feedback, and adapt the application to it.
    This is valuable to do at this point because the project will still be at a stage where I can easily change parts of it without damaging the functionality of any others, something that will not remain true once I have started finalising the interface and re factoring the code.
    \paragraph{•}
    Finally, I can fully implement the "nitty-gritty" of the user interface, adapting my rules to ensure no functionality on any page is compromised.
    I will start this with layout and structure, making sure all the elements of the page are located on it so as to follow my rules.
    The last step is configuring minor properties such as font and colour.
    \paragraph{•}
    The project will then move onto testing and review, detailed later.
    
    \subsection{Problem Structure}
    \paragraph{•}
    Here begins my documentation of the plan I talked about above.
    I have decided to express the first part of my plan as a set of flowcharts, one for each discrete sub system within the application (please note that where user input is required followed by a decision, I have concatenated the input and decision elements into one decision element for the sake of brevity).
    I have decided to compartmentalize the problem as follows.
    \subsubsection{Pages and Areas}
    \paragraph{User Authentication}
    This is key to ensuring the function of the application remains organised and track able.
    All major actions will be logged and tagged with the user that made them, which will help with identification of problems both in full operation, where administrators can trace problems to their source and find the perpetrator, and in development, where I can trace more obscure issues and help myself keep track of what I have done in debugging.
    \begin{figure}[h]
    \includegraphics[width=\textwidth]{loginSystem.png}
    \centering
    \end{figure}
    \paragraph{•}
    A Session refers to the user's connection to the host computer; it is persistent while the user remains connected to the web application and can have many properties and pieces of data attached to it.
    The Active List is the conceptual area in memory where the hosting machine will keep track of all the currently active Sessions.
    \newpage
    \paragraph{Store Main Area}
    This page/area represents the forefront of the website as it is presented to the customer, and thus must be "slick" and comprehensive.
    According to my research, I have planned out filtering and sorting features within the page.
    \begin{figure}[h]
    \includegraphics[width=\textwidth]{storefrontMain.png}
    \centering
    \end{figure}
    \paragraph{•}
    The algorithms used for sorting and filtering will be covered in more details in the algorithms section below.
    \newpage
    \paragraph{Product View Page}
    This page will be the "detailed" display of all the information regrading the product.
    It will show a set of images and a written, plain text description.
    Customers will be able to add a given amount of a product to their "cart" there.
    It is \textit{imperative} that the information displayed on this page is plentiful, and very legible.
    \begin{figure}[h]
    \includegraphics[width=\textwidth]{productPage.png}
    \centering
    \end{figure}
    \paragraph{•}
    The cart should be a collection of products stored in a group labelled with what customer has them in their cart.
    It should be independent of the Sessions so that customers can leave the website or sign out without losing the items in their cart.
    Users who aren't logged in to a customer account may not possess a cart because employees are not authorized to make purchases on the site and people who are not logged in at all may not possess a cart because an account is needed to make a purchase (so purchases are track able).
    \newpage
    \paragraph{Cart Page}
    The cart page shows the customer what they currently have in their cart, lets them edit amounts  and remove products.\\
    More importantly, this is the page where users will make their actual purchases from.
    There are several factors which should be considered in regard to this feature:
    \begin{itemize}
    \item Whether there is enough of all products in the inventory to supply the user's purchase
    \item The user's payment method
    \item The user's delivery address
    \end{itemize}
    After poring over these, I produced the following method.
    \begin{figure}[h]
    \includegraphics[width=\textwidth]{cartPage.png}
    \centering
    \end{figure}
    \paragraph{•}
    The transaction must be handled individually, as it's own process.
    While I cannot guess yet, managing monetary transactions may well prove to be out of the scope of this project, but this is yet to be proved.
    \newpage
    \paragraph{Physical Market Management Page}
    This page will be where the employee interacts with all features related to managing stock at third party events.
    Tt's appearance could quickly get confusing, so careful UI design is important.
    \begin{figure}[h]
    \includegraphics[scale=0.6]{physicalMarket.png}
    \centering
    \end{figure}
    
    \subsection{Algorithms}
    \subsubsection{Quick Sort}
    \paragraph{} One of the complex algorithms I will employ will be a sorting algorithm to sort lists of products to be displayed on the store front in good time.
    I chose the quick sort algorithm for this purpose because it is highly efficient across most datasets, having $O(log(n))$ average complexity and $O(n^2)$ worst case complexity, and because it offers the opportunity to be solved recursively.
    My pseudocode for the algorithm is as follows:
    \begin{lstlisting}[language=psuedocode]

function quicksort(dataset)
    //Contingencies
    switch dataset.length:
        case 1:
            return dataset
        case 2:
            if dataset[1] < dataset[0] then
                dataset[0], dataset[1] = dataset[1], dataset[0]
            endif
            return dataset
    endswitch

    //Find the pivot
    pivotindex = dataset.length / 2
    pivotindex = rounddown(pivotindex)

    //Define the two lists
    list under
    list over

    //Main code block
    for i = 0 to (dataset.length - 1)
        if i == pivotindex then
            continue
        elseif dataset[i] < dataset[pivotindex] then
            under.add(dataset[i])
        elseif dataset[i] >= dataset[pivotindex] then
            over.add(dataset[i])
        endif
    next i

    //Convert to arrays and recur
    array underArray = quicksort(under.toarray())
    array overArray = quicksort(over.toarray())
    
    //Return
    return underArray + dataset[pivotindex] + overArray
endfunction
    \end{lstlisting}
    \paragraph{}
    If the dataset (array) the function is passed is too short, the main code block won't function correctly.
    The first block of code labelled "Contingencies" (beginning line 4) is designed to circumvent this problem; if the function is passed a array of length 1, it will just return it immediately or if it is passed an array of length 2 it will check if they need swapping then return them concatenated into a new array.
    This can also be referred to as the "break case" of the recursive function - it is the place where the function decides whether or not to recur so that the recursion loop isn't infinite.
    \paragraph{}
    The method I chose for finding the pivot in my implementation of quick sort was just to find the element which was halfway through the array; there is much debate over what is the best method, but this one seems the simplest to implement and the most useful for the application at hand.
    I have used rounddown() as a placeholder for a function which rounds down non-integer numbers into integers.
    \footnote{I choose this over rounding up because the arrays are zero based but I expect the lengths to be one based, and this function will compensate for both that and any .5s that may occur in datasets of odd length.}
    \paragraph{}
    When the code refers to the "list" type on lines 18 \& 19, I have called the type list to placehold for the "List" type in C\#, the language I intend to implement this algorithm in.
    A list is an open-ended array which can be appended to and turned into a "true" array at any time.
    \paragraph{}
    Beginning line 23 is the main block of code where the comparisons are made; if the current element is the pivot (checked against the pivot's index as found before) it is skipped, if it is smaller than the pivot it is added to the list of smaller elements and if it is higher or equal then it is added to the list of bigger elements.
    This is the primary logic of quicksort.
    \paragraph{}
    Beginning line 34 is the "recursive case" of the function, i.e. where it recurs (calls itself within itself).
    The function converts the two lists to arrays and passes them to new instances of itself.
    This is powerful because any individual function need only focus on one iteration of the whole sorting process, which makes the code easier to read and understand.
    The algorithm will spawn instances of the function until the break case is tripped, i.e. the array length it is passed is less than 3, when it will just return the array without creating another instance.
    This break case will "travel up" the "stack" of instances and all will return their section of the dataset, sorted, in turn.
    When the initial instance is reached by this phenomenon, it will return the full dataset to the script which called it initially.
    \subsection{Key Variables and Structures}
    Variables are named references to sections of memory.
    They are the label for a data value - referring to them or using them will return you the value of that section of memory.
    Due to this functionality, they are essential to developing a complex program like mine, for storing commonly accessed or changed sections of data and are in fact commonplace in all code scripts for practically all purposes.
    \subsubsection{Global Variables}
    The only variables which need to carry between pages are those related to the system controlling logged in users because all pages need to be able to "tell" information about the user that is viewing them, and all other variables will not be needed by \textit(all) pages.
    These variables will be:
    \begin{itemize}
        \item A string holding the user name of the user that is currently logged in.
        \item A string or boolean representing whether or not the user is an employee or a customer.
        Either of these types could be used; the string would use more memory than necessary but would make the code more understandable whereas the boolean would do the opposite (less memory and less readability).
        \item A boolean holding "true" to show is the user is an administrator, or "false" if they are not.
        Another option to replace both this and the above variable would be something like an Enumerator (a user defined type which can have a set number of enumerable values) which could have the predefined values "Customer", "Employee" and "Administrator" or similar.
        However, using two booleans or a bool and a string makes boolean logic on each page slightly less complicated and reduces the need for iteration where it isn't necessary.
        \item Optionally, a bool showing whether there is a user logged in or the current session is a "guest", ie. not authenticated or formally identified.
        The need for such a variable could be circumvented by simply setting the value of the string holding the user name to be blank or null, but that method could allow people to put exploits in their username string and perform unauthorized and/or unintended acts on the application.
    \end{itemize}
    \subsubsection{Structures}
    The data source is the single key structure in this project.
    It is critical that the data source be able to store all information the website needs, and make it easily accessible and logically organised so that it can be searched, sorted and manipulated.
    To this end, I have chosen to use a relational data base as my data source.
    The additional advantage of using this structure is that within a relational database, the database engine can force referential integrity, which reduces the need for consistency checks at the frontend.
    Within the database I will have six tables, they will be as follows:
    \paragraph{Customers} I have chosen to store customers and employees in separate tables because the data attached to each type is different from the other.
    I am going to investigate the viability of different specific implementations of these tables during development because I do not presently know enough about Microsoft Access to predetermine the method I will use to store customers' data.
    It should, however, contain basic information:
    \begin{description}
        \item[User Name] The user name or handle the customer wishes to be identified by on the site.
        This should be unique.
        \item[Real Name] The real name of the user in some format, so their online account can be easily linked to their real world identity for purposes such as shipping and customer support.
        \item[Password] The private string which the customer uses to verify it is really them whenever they try to log in to the application.
        This information is very sensitive and so I will not store the password verbatim, instead, I will store a hash of the true password (a hash is a value that can be generated from a piece of data, but is generated so that the original data cannot be directly obtained from the hash).
        This means that if the data base's security is breached then attackers will only obtain the hashes, which are useless for logging into the website.
        \item[Address] The address will allow me to implement the feature I described above where the website remembers the customer's delivery infomation for convenience during checkout.
        It could also be used for user verification for customer support.
        \item[Other Personal Info] These could be contact information such as phone numbers or email addresses.
        It is generally helpful to my client's company that this information be attached to their customers, for the aforementioned customer support.
    \end{description}
    \paragraph{Employees}
    The employees table can be a little more concise since not as much personal information is required; that and the inclusion of the administrator boolean are the only differences between it and the customer table.
    \begin{description}
        \item[User Name] The user name or handle the customer wishes to be identified by on the site.
        This should be unique.
        \item[Real Name] This is simply for the sake of simplicity and convenience.
        It could be helpful for identifying employees when a lot are registered.
        \item[Password] This will be a hash of the employee's actual password.
        It will be used for checking their credentials when they try to log in.
        \item[Administrator] This is the boolean variable I described above.
        It will label whether or not the employee is an administrator.
    \end{description}
	\paragraph{Products}
    The products table is very important as it is the table most pages related to the web application's primary function will access.
    \begin{description}
        \item[Product Name] The name of the product; should be unique.
        \item[Type] A string showing whether the product is a clock, coaster or other.
        \item[Stock] An integer storing the amount of the product available in stock (not including the stock which has been taken to a physical market).
        \item[Price] The amount of money, in GBP, that the product will cost a customer.
        Stored as a currency format.
        \item[Creator] The username of the employee who created it.
        This helps with accountability for errors and keeps the history of the database traceable.
        \item[Description] A long string with lots of details about the product which will be displayed on the individual product page.
        \item[Image] Image file(s), one of which will be displayed as the product's thumbnail on the product listing page and all of which will displayed in a "slide show" on the individual product page.
        \item[Band] A string containing the name of the band the product is linked to.
        This allows products to be searched or sorted by what band they are based on.
    \end{description}
    \paragraph{Orders}
    The orders table will record every individual order that has ever been placed on the web application.
    \begin{description}
        \item[ID] This will be an automatically generated number used as the primary key for the database.
        This serves little front-end purpose.
        \item[Date Placed] Quite simply, a string or date format which will store the date and time that the customer placed the order.
        This is essential for statistics, order tracking and customer support.
        \item[Product Ordered] The name of the product which the customer ordered.
        This will be referentially enforced against the names of products registered in the products table.
        \item[Volume Bought] An integer storing how many units of the product the customer ordered.
        \item[Transaction Value] A decimal or price format which stores how much money was requested and received by the application.
        While this could be calculated on the spot whenever the record was accessed, by just multiplying the volume bought by the price in the relevant record in the products table, this method allows for sales or discounted purchases to be stored accurately and eliminates the need to run queries on two different tables to get one piece of data.
        \item[Buyer] The username of the customer who placed the order.
        This should be referntially enforced.
    \end{description}
    \paragraph{Market Items}
    A method to "reserve" items which are taken to a market by an employee is needed; and I have decided to create a separate, simple, table to store those.
    \begin{description}
        \item[Product Name] The name of the product which has been taken out.
        \item[Volume] The amount of the product which has been taken out.
        \item[Employee] The username of the employee who is currently responsible for/in possession of these products.
    \end{description}
    \newpage
    \subsubsection{Intended Implementation}
    \paragraph{Microsoft Access}
    I have chosen the Microsoft Access software to create and manage the database which will support the application.
    Access is freely accessible to me as a student and provides professional level database software which integrates perfectly with my other choices for implementation.
    It allows me to create an automatically enforced relational database which can be queried at any time by any MySQL-compatible code.
    \paragraph{C\#}
    I have chosen the .NET-based language Visual C\# to implement the majority of all logic-based algorithms and scripts in this project.
    My reasoning for this is:
    \begin{itemize}
        \item I am already familiar with C\# and it's syntax, types and object-oriented problem solving method.
        This reduces the possibility of coming across problems I haven't encountered before meaning development wil hopefully be faster.
        It is still inevitable that I will encounter such obstacles, but C\# should throw fewer than other choices.
        \item The .NET foundation provides the excellent ASP.NET libray which contains a set of elements for .NET languages to be used for web development.
        ASP.NET comprises a set of JavaScript elements that imitate HTML elements while simultaneously giving them "hooks" (methods and properties) which are accessible by the .NET-based language behind each page.
        \item ASP also provides the functionality of Master pages, which are a perfect method of implementing the base layouts I describe in a later section.
        These are pages with set elements on them which all pages inherit from, and add their own content to.
        \item C\# integrates well with the Microsoft Access database engine with the use fothe Microsoft-provided OleDB library, which contains many functions for running powerful SQL queries on MS access databases.
    \end{itemize}
        \subsection{Usability Features}
    \paragraph{}
    Since this project is a web application with a public-facing GUI, usability features are a vital consideration at all stages of development.
    The primary focus of that consideration will be UI layout and design; all pages must only show what they need to, with no excess information, in a clear and concise format.
    \paragraph{Base Layout}
    To this end, I intend to have a "base layout" for all pages.
    This will be a blank layout with minimal features (only those which all pages will require) and a large amount of blank space for the content of each page to be placed in.
    There will be two iteration of this "base layout" - one for all employee-only pages, and one for all others.
    The two will have starkly colour schemes so they are clearly distinguished when viewing them in order to clearly show when an employee is viewing a customer area or an exclusive employee only page.
    \paragraph{Nav-Bar}
    A nav bar is an area at the top of the page containing links for navigating the web application.
    These links will be relevant on all pages, they will include a link to the home page, login page and product browsing page; or the statistics page and market page on the employee pages.
    It will also show an element showing the real name of the currently logged in user, with options to sign out and view their profile.
    If no user is logged in, it will show a login button in place of this.
    I plan to implement this feature as the central component of both base layouts.
    \paragraph{Content}
    This is a reserved area of the page where the unique content of each page will be shown, according to the page the user is viewing, for example: on the analytics page graphs will be shown whereas on the product browsing page the product list will be shown.
    It will be the only place each individual page is allowed to place elements and content.
    \paragraph{Background}
    While this may not strictly be a usability "feature", I think there should be an image background at the edges of the page to break up the monotonous colours.
    This has the dual advantage of both making the website more pleasing to look at and easier to read.
    \paragraph{}
    Since this is a web application, the best method to implement these features is, without a doubt, Cascading Style Sheets.
    CSS is a styling language that dictates the appearance, colour and layout of web pages.
    I have chosen it because:
    \begin{itemize}
        \item It allows powerful control of many aspects of web pages as mentioned above with only a few lines of code
        \item It is simple to read, learn and understand because it has little to no syntax variation
        \item It can set presets for elements of particular user defined classes, allowing it to retain consistency across the site with minimal extra effort
    \end{itemize}
    \newpage
    \subsubsection{Customer Base Layout}
    \begin{figure}[h]
        \includegraphics[width=\textwidth]{customerBasic.png}
        \centering
    \end{figure}
    \paragraph{}
    I decided on a muted colour scheme to match the idea of vinyl records for the website.
    Note that the red text and elements in the image are labelling for the purpose of this document, and will not be present in the finished product.
    There may also be objects at the bottom of the page containing things like copyright notices, contant information and disclaimers although I am as yet undecided and will consult the client.
    
    \newpage
    \subsubsection{Employee Base Layout}
    \begin{figure}[h]
        \includegraphics[width=\textwidth]{employeeBasic.png}
        \centering
    \end{figure}
    \paragraph{}
    As before, the blue text and boxes are labels for the sake of illustration.
    \section{Iterative Development}
    \subsection{Data Base}
    Above, I described the contents of each table in the database.
    This section is here to provide a visualisation of the relationships between the tables with a screenshot of the Access relationships screen:
    \begin{figure}[!h]
        \centering
        \includegraphics[width=\textwidth]{dataBaseScreen.png}
    \end{figure}
    \subsection{Annotated Code (Initial Solution)}
    \subsubsection{Preface}
    \paragraph{Code Structure}
    My project is a web application, with the web pages written in ASP.NET and the logic behind them in Visual C\#; as such, an optimal structure and organisation of the code is available.
    Points to remember:
    \begin{enumerate}
        \item All pages are composed of a .aspx file, and a .cs file.
        The .aspx file stores the markup language style code (ASP) that dictates what elements are permanently present on the page, and all their properties.
        The .cs file stores the logic attached to those elements and contains all the C\# code which can refer to all elements present on the ASP page as if they were ordinary objects; it always contains a predefined method called Page\_Load which will be called when the page loads.
        \item There is a master file (in my case two) which all pages inherit from.
        This has common elements like the nav-bar and the content at the bottom of the page.
        It, just like all other pages, has a .cs file attached containing code which applies elements on that page, which are active on all pages dependant on that master file.        
    \end{enumerate}
    \paragraph{Sessions}
    Within ASP, the Session object refers to a class containing an array of objects which are universal across all pages - a set of global variables, if you will.
    This is helpful for implementing code which keeps the user authenticated, as described in the design section and is conveniently named the same thing.
    There are four variables stored in it which I refer to constantly:
    \begin{description}
        \item[isLoggedIn] This is a boolean simply representing whether there is currently a user logged in.
        \item[currentUser] This is a string storing the username of the user currently logged in.
        It's default value (i.e. when no one is logged in) is "" (nothing).
        \item[userType] This is another string storing whether the logged in user is an employee, or a customer.
        It's default value is also "".
        \item[userIsAdmin] A boolean storing whether the logged in user is an administrator.
        Default value false.
    \end{description}
    \newpage
    These are all the classes which contain code needed by many different pages for similar reasons.
    They are not in the master files because not all pages need them, and those that do will likely not need all of them.
    Instead, they are grouped into their own .cs file in order to keep them accessible and grouped together without any other logic making them more difficult to read and change.
    \newpage
    \subsubsection{Logging}
    The following code controls all the logging of all actions in the software, all log entries are processed through this class.
    This is not a webpage, this is just a section of shared code.
    \begin{lstlisting}[language=C]
public class customLogging
{
    public static void newSession()
    {
        string result;
        string dividerASCII = "------------------------------------------";
        result = dividerASCII + generateTimestamp() + dividerASCII;
        writeEntry("");
        writeEntry(result);
    }

    public static void newEntry(string entryText)
    {
        string result = generateTimestamp() + " " + entryText;
        writeEntry(result);
    }

    public static void newException(Exception except)
    {
        string result = generateTimestamp() + " An error occurred in " + except.Source + " with message " + except.Message;
        writeEntry(result);
    }

    private static void writeEntry(string entryText)
    {
        try
        {
            using (StreamWriter logFile = new StreamWriter(@"\\albert \2011\R04637\Computer Science\coursework\mainCoursework\App_Data\log.txt", true))
            {
                logFile.WriteLine(entryText);
            }
        }
        catch (IOException)
        {
            using (StreamWriter logFile = new StreamWriter(@"C:\Users\Edward\Source\Repos\coursework\mainCoursework\App_Data\log.txt", true))
            {
                logFile.WriteLine(entryText);
            }
        }
    }

    private static string generateTimestamp()
    {
        string output = "[" + Convert.ToString(DateTime.Now) + "]";
        return output;
    }
}
    \end{lstlisting}
    The methods are as follows:
    \paragraph{writeEntry} The method that writes the text passed to it to the log file.
    Here, I have used a try-catch statement to bypass a problem I encountered when working on this project between two workstation in different locations - at school and at home.
    Since the application does not run out of the directory containing the pages it is showing (the same directory which contains the logfile) because it executes on the pre installed IIS express server, referential file paths serve no purpose.
    My solution to this was to simply try the file path which would ordinarily contain the logfile on the school hard drive, and switch to that at home if it failed.
    \\
    The method takes a string containing the text it should enter into the file, opens a StreamWriter class (the system class for writing to binary files) and uses it to send the requested text to the file.
    \paragraph{generateTimestamp} This is a string method that returns the current time with square brackets around it, ready to be prefixed onto a log entry.
    \paragraph{newSession} A void method which puts a dividing line in the log file indicating that the server has just started, and the history below it until the next divider is a new instance of the server.
    It also tags it with generateTimestamp's output to mark when the session started.
    This method is only called by the master page constructor.
    \paragraph{newEntry} Another void method which creates a string from the string it is passed and the output of generateTimestamp, and writes it to the log with writeEntry.
    \paragraph{newException} Similar to newEntry but it writes an exception's contents to the log.
    It uses the properties of the exception passed to it "source" and "message" to generate an appropriate entry to the log, timestamp it and write it.
    \newpage
    \subsubsection{Custom Security}
    The customSecurity class only covers MD5 hashing and SQL injection checking.
    \begin{lstlisting}[language=C]
public class customSecurity
{
    public const string sanitizeErrorMessage = "All fields must be full. The (, ), +, -, = and ' characters are not allowed in ANY fields";

    public static bool sanitizeCheck(string[] input)
    {
        bool isClean = true;
        foreach (string i in input)
        {
            if (i.Contains("(") || i.Contains(")") || i.Contains("'") || i.Contains("=") || i.Contains("-") || i.Contains("+"))
            {
                isClean = false;
                break;
            }
            if (i == "")
            {
                isClean = false;
                break;
            }

        }
        return isClean;
    }

    public static string generateMD5(string input)
    {
        var md5 = System.Security.Cryptography.MD5.Create();
        byte[] inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
        byte[] hash = md5.ComputeHash(inputBytes);
        string output = "";
        for (int i = 0; i < hash.Length; i++)
        {
            output = output + hash[i].ToString("x2");
        }
        return output;
    }
}
    \end{lstlisting}
    \paragraph{sanitizeErrorMessage}
    A custom error message stored so that error returns can use it.
    This exists to retain consistency, i.e. all returns show the same message when SQL - relevant characters are found.
    \paragraph{sanitizeCheck}
    According to my success criteria, the application must adequately protect the users' data.
    A common method of trying to breach application which use SQL to interact with their databases is called "SQL Injection" - this is when an attacker enters an SQL command into an input they think will be checked against the database.
    This can be used to issue commands to the database without correct authentication - attackers can log in, drop tables and commit other destructive actions.
    The most common way to prevent this is referred to as Sanitization, when inputs are checked for characters that could be used in an SQL statement and either remove them or refuse the input if they are found.
    I have adopted this as no inputs require any of these characters as part of their function; this code takes an array of input box contents and returns true or false depending on if any of those inputs contain SQL sensitive characters (specifically (,),=,-,+).
    It also serves to make inputs required as it will return false if any of them are blank.
    \paragraph{generateMD5}
    As stated in the key structures section of my design, all passwords stored in the database will be hashed so in the event that they are comnpromised, the password values are of little use.
    \\
    The code uses the System.Security.Crypography library to access the algorithms required to generate MD5 hashes from byte data.
    The function takes a string and creates a new instance of the MD5 class from the cryptography library.
    It converts the input into an array of bytes using the System.Text.Encoding.ASCII class (which changes ASCII values into byte data, i.e. strings into binary)
    Another array of bytes is generated using the ComputeHash method of our Cryptography.MD5 instance (called md5).
    The string output is defined and assigned as "" (this is because the next for loop requires an already existing string to append to).
    A for loop is run up to the length of the array of bytes (the output data) which appends the string output with each byte using the .ToString method which most objects in C\# possess.
    The "x2" argument specifies that each string output should be capitalised (I use this for consistency).
    \newpage
    \subsubsection{Data Set}
    \paragraph{}
    C\# and the .NET framework in general provide DataSets for the use of developers to easily interface with a data source.
    The DataSet automatically generates code using OleDB (the Microsoft database engine) for each query you add to it.
    I have constructed one central DataSet which holds all my tables and several queries for each.
    The SQL query statements will be shown and annotated as they are used.
    The full dataset is shown below:
    \begin{figure}[h]
        \centering
        \includegraphics[width=\textwidth]{defaultDataSet.png}
    \end{figure}
    Each table is shown in a box, with the adaptor (the containing object with all the user-defined queries in it) in an adjoining box below that
    Data relationships are shown with lines connecting the tables, data fields by rows in the table box and queries in the adaptor box.
    \newpage
    \subsubsection{Customer Master Page}
    There are two master pages on my project.
    Each of them contains all the references needed for an ASP page, and some C\# code to supplement them.
    The master customer page contains the navbar, which consists of static links with no code behind them but HTML and a label showing the login status of the current user, a placeholder panel for the content and an area under a horizontal rule which contains a button to sign them out (if they are signed in) and a button to redirect them to the employee side of the site if they are logged in as an employee.
    The code behind this is:
    \begin{lstlisting}[language=C]
protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToString(Session["currentUser"]) == "")
    {
        usernameLabel.Text = "No user logged in";
        signOut.Visible = false;
        userProfileNavbar.Visible = false;
    }
    else
    {
        usernameLabel.Text = "Welcome,\n" + Session["currentUser"] + "!";
        signOut.Visible = true;
    }

    if (Convert.ToString(Session["isLoggedIn"]) == "True")
    {
        loginNavbar.Visible = false;
    }

    if (Convert.ToString(Session["userType"]) != "employee")
    {
        employeeRedirect.Visible = false;
    }
}

protected void signOut_Click(object sender, EventArgs e)
{
    Session["isLoggedIn"] = "False";
    Session["currentUser"] = "";
    Session["userIsAdmin"] = "False";
    Session["userType"] = "";
    customLogging.newEntry("User logged out");
    Server.Transfer("~/default.aspx", false);
}

protected void employeeRedirect_Click(object sender, EventArgs e)
{
    Server.Transfer("~/staffOverview.aspx", false);
}
    \end{lstlisting}
    \paragraph{Page\_Load} Determines whether to display various controls at the bottom of the page.
    It first checks if a user is logged in by converting the currentUser session to a string and seeing if it is blank.
    If it is, the label at the footer is set to show "No User Logged In", the sign out button is set to be invisible (and therefore uninteractable; there is no need to hide the employee redirect button because this is invisible by default) and an element on the navbar which would redirect the user to their profile is set to be invisible.
    If not, the button is confirmed to be visible and the label is set to show the current user's name with a welcome message.
    If the "isLoggedIn" session is set to true, the login link on the navbar is hidden.
    If the "userType" session isn't marked as employee, the employee redirect button is set to be invisible.
    \paragraph{signOut\_Click} is the click event for the sign out button.
    It resets all the user-related sessions to their default state, logs the sign out and redirects the user to the home page.
    \paragraph{employeeRedirect\_Click} just binds the employee redirect button to redirect the user to the employee page.
    \newpage
    \subsubsection{Employee Master Page}
    The employee master page contains the navbar, the content placeholder and the footer with the sign out button on it just as the customer master does.
    \begin{lstlisting}[language=C]
protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToString(Session["userType"]) != "employee")
    {
        Server.Transfer("~/default.aspx", true);
    }
    if (Convert.ToString(Session["isLoggedIn"]) == "True")
    {
        loginNavbar.Visible = false;
    }
    usernameLabel.Text = "Welcome\n, employee " + Session["currentUser"] + "!";
    signOut.Visible = true;
}

protected void signOut_Click(object sender, EventArgs e)
{
    Session["isLoggedIn"] = "False";
    Session["currentUser"] = "";
    Session["userIsAdmin"] = "False";
    Session["userType"] = "";
    customLogging.newEntry("User logged out");
    Server.Transfer("~/default.aspx", false);
}

protected void employeeIn_Click(object sender, EventArgs e)
{
    Server.Transfer("~/employeeLogin.aspx", false);
}

protected void customerRedirect_Click(object sender, EventArgs e)
{
    Server.Transfer("~/default.aspx", false);
}
    \end{lstlisting}
    \paragraph{Page\_Load} serves a similar purpose to on the customer page, checking sessions and performing the appropriate actions.
    First and foremost, if the user isn't marked as an employee with userType, they are immediately redirected to the customer home page.
    This prevents unauthorized access to the employee side of the website, so all page which inherit from this master page will be inaccessible to anyone not marked as an employee.
    The username label is set to show a welcome message and the sign out button is set to be visible.
    \paragraph{signOut\_Click} is the event method for when the sign out button is clicked.
    It does exactly the same thing as the sign out button on the customer master page, clearing all sessions and redirecting the user to the customer home page.
    \paragraph{employeeIn\_Click} just redirects the user to the employee login page.
    \paragraph{customerRedirect\_Click} just redirects the user to the customer half of the site because this is difficult to access for an employee otherwise.
    \newpage
    \subsubsection{Log In}
    \begin{lstlisting}[language=C]
public partial class customerLogin : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (Convert.ToString(Session["isLoggedIn"]) == "True")
        {
            Server.Transfer("~/default.aspx", false);
        }
    }

    protected void submitCustomerCredentialsButton_Click(object sender, EventArgs e)
    {
        if (customSecurity.sanitizeCheck(new string[] { customerUsernameBox.Text, customerPasswordBox.Text }))
        {
            string attemptedName = customerUsernameBox.Text;
            using (var checkCredentials = new defaultDataSetTableAdapters.customersTableAdapter())
            {
                if (checkCredentials.loginCheck(attemptedName, customSecurity.generateMD5(customerPasswordBox.Text)) != null)
                {
                    Session["isLoggedIn"] = "True";
                    Session["currentUser"] = attemptedName;
                    Session["userType"] = "customer";
                    Session["userIsAdmin"] = "False";
                    customLogging.newEntry("Customer " + attemptedName + " logged in");
                    Server.Transfer("~/default.aspx", false);
                }
                else
                {
                    customerLoginReturnLabel.Text = "The Username or Password is incorrect.";
                    customLogging.newEntry("Someone attempted to login as a customer with username '" + attemptedName + "' but the credentials were incorrect");
                }
            }
        }
        else
        {
            customerLoginReturnLabel.Text = customSecurity.sanitizeErrorMessage;
        }
    }

    protected void registerButton_Click(object sender, EventArgs e)
    {
        Server.Transfer("registerCustomer.aspx", false);
    }

    protected void employeeRedirect_Click(object sender, EventArgs e)
    {
        Server.Transfer("employeeLogin.aspx", false);
    }
}
    \end{lstlisting}
    \paragraph{The Page}
    There are two log in pages in my project, one for the customers and one for the employees; because the customer and employee tables are seperate, it is more convenient to seperate the logic for each table into two seperate pages/files.
    In terms of appearance, the two pages are identical but for the inclusion of a button on the customer page which redirects the user to the customer register page.
    Otherwise, both pages contain a text box for the user name of the user and their password (customerUsernameBox and customerPasswordBox or equivalent), a submit credentials button (submitCustomerCredentialsButton or equivalent) and finally a button to redirect the user to the employee login or customer login as appropriate (employeeRedirect or equivalent).
    Both pages inherit from Customer.Master.
    \paragraph{Page\_Load}
    This page should not be accessible by people that are already logged in, as logging in again is unnecessary if they are already logged in and could cause unforeseen problems.
    This checks the session "isLoggedIn", and if it tagged as true then it redirects the user to the relevant homepage with the Server.Transfer method (this is used on almost all pages to redirect people - it's arguments are the path of the page to redirect to and whether to "preserve" the form it is currently loading, for my purposes this is always false).
    In the employee file, it will redirect to the employee homepage, which will then redirect to the customer homepage if it is a customer logged in.
    \paragraph{submitCustomerCredentialsButton\_click}
    A method called when the submit button is clicked (ASP automatically generates blank methods linked to each button's onclick event, comprised of the name of the button followed by "\_click").
    Within this method, I have used two nested if statements with boolean logic to check the inputs for validity.
    The first ensures that both input boxes are free of SQL characters with customSecurity.sanitizeCheck and returns the appropriate error message to the return box if not, while the second runs a query against the database:
    \begin{lstlisting}[language=SQL]
SELECT COUNT(*) AS Expr1
FROM customers
GROUP BY username, [password]
HAVING (username = ?) AND ([password] = ?)
    \end{lstlisting}
    This query will return a DataRow type if an entry with matching credentials is found, and null if not.
    The boolean logic in the if statement checks if something was returned, and if it was it runs the code within it.
    If null is returned then it will not run anything and change the error message label to inform the user they have input incorrect credentials.
    The code within the if statement sets all the appropriate session data as described previously, using the username string the user gave as the username and setting the administrator \& type values to false and customer respectively on this page.
    It will also log the user entering the site.
    On the employee page, lines 24 to 26 are replaced with:
    \begin{lstlisting}[language=C]
Session["userIsAdmin"] = Convert.ToBoolean(loginCheck);
if (Convert.ToBoolean(Session["userIsAdmin"]))
{
    customLogging.newEntry("Admin " + attemptedName + " logged in");
}
else
{
    customLogging.newEntry("Employee " + attemptedName + " logged in");
}
Server.Transfer("~/staffOverview.aspx", false);
    \end{lstlisting}
    The changes this code introduces are that the return of the query is converted into a boolean with the default static class Convert - this works because the query run for that page is
    \begin{lstlisting}[language=SQL]
SELECT admin
FROM employees
GROUP BY username, [password], admin
HAVING (username = ?) AND ([password] = ?)
    \end{lstlisting}
    Which returns just the value of the admin field instead of the whole DataRow so the only value for Convert to operate on is the one we want.
    The resulting value is stored in the userIsAdmin session.
    The same session is immediately checked again to decide what to post to the log; if it returns true then the log is told an administrator logged on and if false that an employee logged on.
    The last line redirects the newly-logged in user to the staff overview page instead of the customer home page.
    \newpage
    \subsubsection{Product Class}
    My project needs to deal with lots of information about the products of the client constantly as part of it's base function.
    The code which deals with this is best abstracted enough to be omni-purpose across the site, with little modification needed to use it on different pages for different purposes.
    Most pages related to products need to be able to display a list of products which can be sorted and filtered - to this end I decided to write a instantiable class representing one product and attach code to it that would let it gather it's data for itself.
    Eventually, I wrote the following:
    \begin{lstlisting}[language=C]
public class product
{
    private defaultDataSetTableAdapters.productsTableAdapter adapter = new defaultDataSetTableAdapters.productsTableAdapter();

    private productStruct ProductInfo = new productStruct();
    public productStruct productInfo
    {
        get
        {
            return ProductInfo;
        }
    }
    public int newStock { get; set; }

    public product(string iniName)
    {
        getData(iniName);
    }
    public product(DataRow row)
    {
        ProductInfo.productName = Convert.ToString(row[0]);
        ProductInfo.displayName = Convert.ToString(row[3]);
        ProductInfo.stock = Convert.ToInt32(row[1]);
        ProductInfo.price = Convert.ToDecimal(row[2]);
        ProductInfo.band = Convert.ToString(row[7]);
        ProductInfo.description = Convert.ToString(row[8]);
        ProductInfo.imagePath = Convert.ToString(row[6]);
        ProductInfo.type = Convert.ToString(row[4]);
    }
    
    public void saveStock()
    {
        adapter.updateStock(newStock, ProductInfo.productName);
        ProductInfo.stock = newStock;
        newStock = 0;
    }

    public void refresh()
    {
        getData(ProductInfo.productName);
    }

    private void getData(string searchName)
    {
        var rows = adapter.getDataTable(searchName);
        DataRow row = rows[0];
        ProductInfo.productName = searchName;
        ProductInfo.displayName = Convert.ToString(row[3]);
        ProductInfo.stock = Convert.ToInt32(row[1]);
        ProductInfo.price = Convert.ToDecimal(row[2]);
        ProductInfo.band = Convert.ToString(row[7]);
        ProductInfo.description = Convert.ToString(row[8]);
        ProductInfo.imagePath = Convert.ToString(row[6]);
        ProductInfo.type = Convert.ToString(row[4]);
    }
}
    \end{lstlisting}
    \paragraph{Properties and Variables}
    A property in C\# is an attribute of a class which allows outside code to read and write to objects within it.
    This can be used to make certain values read-only or write-only, or attach code to such events to control what conditions the object(s) can be accessed under.
    It is good practice to implement properties instead of tagging objects within as public because it ensures outside code cannot accidently or deliberately interfere with the objects within the class; while I will be the only contributor to this application's codebase this is not strictly necessary because I know how the class works and don't need to interfere with it, it remains good practice to implement.
    The properties and variables defined in lines 3 to 13 are as follows:
    \begin{itemize}
        \item \textbf{adapter} is the adaptor which the product will use to pull information from.
        \item \textbf{ProductInfo} a custom structure which holds all the information about the product in an uncomplicated, grouped object.
        It's structure is:
        \begin{lstlisting}[language=C]
    public struct productStruct
    {
        public string productName;
        public string displayName;
        public int stock;
        public decimal price;
        public string band;
        public string description;
        public string imagePath;
        public string type;
    }
        \end{lstlisting}
        \begin{itemize}
            \item productName is the camel case name of the product - camel case does not contain spaces and capitalizes the first letter of all words/components but the first.
            I chose this because it maximizes compatibility since it doesn't have any spaces, which can make string manipulation on it easier, and so that strange capitalizations won't allow duplicate products in the data base.
            Also, it is in keeping with my method of using camel case for all my variables and objects in my code.
            \item displayName is the original name the employee who created the product set as the name.
            \item stock is an integer value showing how much stock is left in the inventory.
            \item price is a decimal detailing how much, in GBP, one unit of the product costs.
            \item description is a written description of the product which is defined when the product is created.
            \item imagePath is a file path to the image of the product.
            It should ideally be images/productname.png.
            \item type is the type of product it is, i.e. coaster or clock.
        \end{itemize}
        An additional advantage is that using a struct like this allows me to assign a name to each field instead of having to check by index.
        \\
        \item \textbf{productInfo} is the property used to access the information in ProductInfo.
        It is read only.
        \item \textbf{newStock} This is a simple integer that can be read or written to which a later method will use to change the stock value of a product in the database.
    \end{itemize}
    \paragraph{Constructors}
    In C\#, constructors are declared with "public objectName(arguments)", without a type specifier and with the same name as the parent object.
    There are two contructors in this class - they are overloaded (i.e. the compiler chooses which one to use based on what parameters are given when the object is instantiated):
    \begin{enumerate}
        \item Beginning line 15, the base constructor takes a string holding the productName of the product to load into the new instance.
        It runs the getData() method using this, explained below.
        \item Beginning line 19, the secondary constructor takes a full datarow which would typically be returned by a DataSet query and assigns all of the information in productStruct to the correct fields in that row.
    \end{enumerate}
    \paragraph{Methods}
    There are three methods in the product class:
    \begin{itemize}
        \item \textbf{saveStock} uses adaptor to write the value of newStock to the database with the query updateStock, which consists of:
        \begin{lstlisting}[language=SQL]
    UPDATE products
    SET stock = ?
    WHERE (productName = ?)
        \end{lstlisting}
        This changes the value of the stock field in all entries where productName matches what is given.
        saveStock also updates the stock value in ProductInfo and resets the value of newStock to 0.
        \item \textbf{refresh} runs getData again using the productName variable in ProductInfo.
        \item \textbf{getData} is a private method for use only within the class which runs the query getDataTable using adaptor.
        getDataTable contains:
        \begin{lstlisting}[language=SQL]
    SELECT productName, stock, price, displayName, productType, creator, [image], [band], description
    FROM products
    WHERE (productName = ?)
        \end{lstlisting}
        This searches for productName in the table and returns the entire contents of the table when it finds a match.
        getData uses that information to populate ProductInfo using the appropriate data fields.
    \end{itemize}
    The product class itself is relatively barebones since most of the logic related to organising and presenting products is contained in later objects.
    \newpage
    \subsubsection{productPanel Class}
    I needed a way to show products consistently across all pages and manually writing the code for displaying products on every page that needed it would take more time and be less efficient than alternative solutions.
    To accomplish this, I wrote a class which inherits from the ASP.NET Panel, giving me the advantage of just being able to add the object as it is to forms so it will just render itself.
    \begin{lstlisting}[language=C]
public class productPanel : System.Web.UI.WebControls.Panel
{
    public productStruct info;
    public productPanel(productStruct productInfo)
    {
        info = productInfo;

        this.CssClass = "productDisplayPanel";
        this.ID = info.productName + "Panel";

        Image displayedImage = new Image()
        {
            CssClass = "productImage",
            ID = info.productName + "ImageTag",
            ImageUrl = info.imagePath,
            Height = 400,
            Width = 400
        };
        displayedImage.Attributes.Add("runat", "server");
        this.Controls.Add(displayedImage);
        this.Controls.Add(new LiteralControl("<br />"));

        Label nameTag = new Label()
        {
            CssClass = "nameTag",
            Text = info.displayName,
            ID = info.productName + "NameTag"
        };
        nameTag.Attributes.Add("runat", "server");
        this.Controls.Add(nameTag);
        this.Controls.Add(new LiteralControl("<br />"));

        Label priceTag = new Label()
        {
            CssClass = "priceTag",
            Text = "£" + commonClasses.common.formatPrice(info.price),
            ID = info.productName + "PriceTag"
        };
        priceTag.Attributes.Add("runat", "server");
        this.Controls.Add(priceTag);

        Label stockTag = new Label()
        {
            CssClass = "stockTag",
            ID = info.productName + "StockTag"
        };
        if (info.stock == 0)
        {
            stockTag.Text = "Out of stock";
        }
        else
        {
            stockTag.Text = Convert.ToString(info.stock) + " in stock";
        }
        stockTag.Attributes.Add("runat", "server");
        this.Controls.Add(stockTag);
        this.Controls.Add(new LiteralControl("<br />"));

        Label descriptionTag = new Label()
        {
            CssClass = "descriptionTag",
            Text = Convert.ToString(info.description),
            ID = info.productName + "DescriptionTag"
        };
        descriptionTag.Attributes.Add("runat", "server");
        this.Controls.Add(descriptionTag);
        this.Controls.Add(new LiteralControl("<br />"));
    }
}
    \end{lstlisting}

    \paragraph{Properties}
    The only property in this class is productInfo, which is just a productStruct initialized in the constructor.
    \paragraph{Contructor}
    This class has only one constructor, which serves a double purpose as the only method in the class.
    The constructor initializes a set of controls which together make up the whole panel and contain all information the panel should display.
    First, the ID and CssClass of the panel itself using the dynamic referrer "this".
    For each individual control:
    \begin{enumerate}
        \item The ID and CssClass are set.
        The ID is set to be the name of the product the panel is being generated ofr appended with the name of the control (for the panel, an example ID would be "sampleClock3Panel").
        The CSS class is simply the name of the object because all similar objects need the same CSS class to have the same styling applied to them.
        \item Specific properties for each control are set - see below for these.
        \item The control has the runat Attribute set to "server" using Attributes.Add() so that it runs server-side, not client-side, which would cause persistency problems.
        \item The control is added to the panel's controls array using this.Controls.Add() - the controls array is an array in productPanel inherited from Panel which contains all the controls which are displayed within the panel.
        \item An HTML $<$br /$>$ (breakline, essentially a manual "return" key) is added by instantiating a LiteralControl in order to create some space between elements.
    \end{enumerate}
    \paragraph{}
    The individual controls are:
    \begin{itemize}
        \item \textbf{displayedImage} is the thumbnail (small cover image) for the product.
        It is set to display the image at the path at the imagePath property of the info productStruct and to be 500\*500 so all thumbnails are the same size.4
        \item \textbf{nameTag} is the label which will show the name of the product.
        It's Text property is set to the displayName property of info.
        \item \textbf{priceTag} displays the price of 1 unit of that product.
        It's Text property is set to the stored price of the product from info and prefixed with a "£" character.
        \item \textbf{stockTag} is a label which just shows the integer value of how much of that product is left in the inventory.
        It's Text property is set to the stock value of info.
        \item \textbf{descriptionTag} is a label which will hold the description of the product.
        It's Text property is set to the description of the product using info.
    \end{itemize}
    \paragraph{Revision 29/04/18}
    There are some issues with styling using the current layout.
    I decided to create another panel to hold all the elements except the image so that I could apply styling to the positioning of the non-image elements together:
    \begin{lstlisting}[language=C]
public product info { get; }
public productPanel(product productInfo)
{
    info = productInfo;

    this.CssClass = "productDisplayPanel";
    this.ID = info.productName + "Panel";

    Image displayedImage = new Image()
    {
        CssClass = "productImage",
        ID = info.productName + "ImageTag",
        ImageUrl = "~/images/" + info.imagePath,
        Height = 100,
        Width = 100
    };
    displayedImage.Attributes.Add("runat", "server");
    this.Controls.Add(displayedImage);

    Panel textWrapper = new Panel()
    {
        CssClass = "textWrapper",
        ID = info.productName + "TextWrapper"
    };
    textWrapper.Attributes.Add("runat", "server");

    Label nameTag = new Label()
    {
        CssClass = "nameTag",
        Text = info.displayName,
        ID = info.productName + "NameTag"
    };
    nameTag.Attributes.Add("runat", "server");
    textWrapper.Controls.Add(nameTag);

    Label priceTag = new Label()
    {
        CssClass = "priceTag",
        Text = "£" + commonClasses.common.formatPrice(info.price),
        ID = info.productName + "PriceTag"
    };
    priceTag.Attributes.Add("runat", "server");
    textWrapper.Controls.Add(priceTag);

    Label stockTag = new Label()
    {
        CssClass = "stockTag",
        ID = info.productName + "StockTag"
    };
    if (info.stock == 0)
    {
        stockTag.Text = "Out of stock";
    }
    else
    {
        stockTag.Text = Convert.ToString(info.stock) + " in stock";
    }
    stockTag.Attributes.Add("runat", "server");
    textWrapper.Controls.Add(stockTag);

    Label descriptionTag = new Label()
    {
        CssClass = "descriptionTag",
        Text = Convert.ToString(info.description),
        ID = info.productName + "DescriptionTag"
    };
    descriptionTag.Attributes.Add("runat", "server");
    textWrapper.Controls.Add(descriptionTag);

    this.Controls.Add(textWrapper);
}
    \end{lstlisting}
    \newpage
    \subsubsection{productList Class}
    This class contains all the logic for sorting, filtering and otherwise comparing products.
    Since the class is extremely large, I have split it up into groups of similar functions; each section has an accompanying code block, all of which are in order.
    I have omitted the class declaration to make the beginning and end sections easier to read, all of the following is encapsulated in ordinary "class productList {}" tags.
    \paragraph{Properties and Variables}
    \begin{lstlisting}[language=C]
		private defaultDataSetTableAdapters.productsTableAdapter adapter = new defaultDataSetTableAdapters.productsTableAdapter();
		private product[] masterList;
		private product[] WorkingList;
		public product[] list
		{
			get
			{
				return WorkingList;
			}
		}
    \end{lstlisting}
    \begin{itemize}
        \item \textbf{adapter} is, as before, the adapter the productList will use to interface with the database.
        \item \textbf{masterList} is one of two arrays of type product; this one stores the whole contents of the database table when the class is initialized.
        The class won't change the contents of this once it is initialized or it is specifically instructed to.
        \item \textbf{workingList} is the "primary" product array; it is copied from the master list upon initialization then all filtering and sorting is applied to it.
        The advantage of this method is that when the sort or filter needs to be reset, the database does not have to accessed twice which would make the application slower.
        \item \textbf{list} is the property allowing outside access to the working list.
        The master list is private with no property to prevent outside code from interfering with the contents of it because if it did, productList might not function correctly.
    \end{itemize}
    \paragraph{Basic Methods and Constructors}
    The class has a large amount of constructor overloads to account for all possible situations which serve to make it more adaptible.
    It can initialize using an array of products, an array of the names of products, a DataTable of products and, by default, from all the products in the table.
    Many of these features may prove to be redundant later and I may not use some so it is unlikely all these construction methods will survive into the finished project.
    \begin{lstlisting}[language=C]
public void resetWorkingList()
{
    WorkingList = masterList;
}

public Panel[] generateControls()
{
    Panel[] result = new Panel[WorkingList.Length];
    for (int i = 0; i < WorkingList.Length; i++)
    {
        result[i] = new productPanel(WorkingList[i].productInfo);
    }
    return result;
}

public void setWorkingList(product[] array)
{
    WorkingList = array;
}

public productList()
{
    var data = adapter.GetData();
    int i = 0;
    masterList = new product[data.Rows.Count];
    foreach (DataRow row in data.Rows)
    {
        masterList[i] = new product(row);
        i++;
    }
    WorkingList = masterList;
}
public productList(string[] productNames)
{
    int i = 0;
    foreach (string str in productNames)
    {
        masterList[i] = new product(str);
        i++;
    }
}
public productList(DataTable data)
{
    int i = 0;
    foreach (DataRow row in data.Rows)
    {
        masterList[i] = new product(row);
        i++;
    }
    WorkingList = masterList;
}
public productList(product[] products)
{
    masterList = products;
    WorkingList = masterList;
}
    \end{lstlisting}
    The constructors are, in the order they are laid out in the code:
    \begin{enumerate}
        \item The first constructor pulls the whole contents of the database into the class.
        It uses the adaptor to get a DataTable (declared with the keyword "var" here, which sets the type to the appropriate one to store what it's being set to).
        The master list is initialized as a blank array with the same length as there are rows in the datatable, so there are exactly the right amount of elements to store all currently registered products.
        \item Uses an array of strings containing the names of the products that should be put into the master list.
        This uses the constructor for the product class that takes a string containing the name of the product to initialize and generates a product for each entry in the string.
        Letting each product initialize itself could prove to be a slow method as a database call must be made for each product which could create massive latency issues but I will review in testing.
        \item Uses a premade DataTable passed to it on initialization to initialize each product in the list.
        Works similarly to \#1 but doesn't create it's own table.
        Having this constructor lets me run LINQ queries on the table in other objects to filter it, which can sometimes be more powerful than just using SQL and moreover can be checked and debugged inside Visual Studio effectively.
    \end{enumerate}
    \paragraph{Revision 24/04/18}
    I have changed some of the constructors prior to testing because upon reading back through, some clearly won't work as they don't set the working list or actually initialize the master list at all.
    I have added masterList initialization to the second and third constructors, and WorkingList intialization to the second constructor:
    \begin{lstlisting}[language=C]
public productList()
{
    var data = adapter.GetData();
    int i = 0;
    masterList = new product[data.Rows.Count];
    foreach (DataRow row in data.Rows)
    {
        masterList[i] = new product(row);
        i++;
    }
    WorkingList = masterList;
}
public productList(string[] productNames)
{
    int i = 0;
    masterList = new product[productNames.Length];
    foreach (string str in productNames)
    {
        masterList[i] = new product(str);
        i++;
    }
    WorkingList = masterList;
}
public productList(DataTable data)
{
    int i = 0;
    masterList = new product[data.Rows.Count];
    foreach (DataRow row in data.Rows)
    {
        masterList[i] = new product(row);
        i++;
    }
    WorkingList = masterList;
}
public productList(product[] products)
{
    masterList = products;
    WorkingList = masterList;
}
    \end{lstlisting}
    There are several basic methods which are included above the constructors, detailed here:
    \begin{itemize}
        \item \textbf{resetWorkingList} just discards the current workingList and sets it to the contents of the master list.
        It is there for when sorting and filtering need to be cleared and removed.
        \item \textbf{generateControls} generates an array of productPanels, one for each product in the working list and returns it.
        \item \textbf{setWorkingList} exists purely so that outside classes can set the contents of the workingList.
        This is largely just a contingency for the rare occasion where I may need to set the WorkingList outside the class but I suspect I will not need it and so it will also likely not make it into the final application.
    \end{itemize}
    \newpage
    \paragraph{Filtering and Sorting}
    Unfortunately, the following code is extremely long and so this section will be more difficult to follow.
    The class contains extensive logic for filtering and sorting the contents of the workingList, primarily for the use of the storefront page (the code has been kept within the class without any web based dependencies in the event that I need to be able to use this logic on any other page).
    The sheer length of this code is mostly due to a limitation of C\# which doesn't allow generics to filter what types they accept; if this wasn't the case I would be able to make a highly abstracted, generic quicksort function which all these methods could use but as it is I can't dictate what types the function would accept.
    \\
    All the logic is presented to outside code using only two methods, simply "sort" and "filter".
    These methods use a switch to find what type of sort to apply and what field to apply it to; this keeps the outside appearance simple and interaction with the class understandable, letting the code within the class organise the implementation of quicksort and filtering.
    \paragraph{Sorting}
    \begin{lstlisting}[language=C]
public void sort(bool ascending, string sortType)
{
    switch (sortType)
    {
        case "price":
            WorkingList = sortPrice(WorkingList, ascending);
            break;
        case "stock":
            WorkingList = sortStock(WorkingList, ascending);
            break;
        case "name":
            WorkingList = sortName(WorkingList, ascending);
            break;
        case "band":
            WorkingList = sortBand(WorkingList, ascending);
            break;
        default:
            throw new System.ArgumentException("The sort type must be one of the specified values.");
    }
}

private static product[] sortPrice(product[] input, bool ascending)
{
    if (input.Length <= 1)
    {
        return input;
    }
    else if (input.Length == 2)
    {
        if ((input[0].productInfo.price > input[1].productInfo.price && ascending) || (input[0].productInfo.price < input[1].productInfo.price && !ascending))
        {
            product temp = input[0];
            input[0] = input[1];
            input[1] = temp;
        }
    }

    product[] subArray;
    List<product> subList = new List<product>();
    product[] superArray;
    List<product> superList = new List<product>();
    int pivotIndex = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(input.Length) / 2)) - 1;

    for (int i = 0; i < input.Length; i++)
    {
        if (i == pivotIndex)
        {
            continue;
        }
        else if (input[i].productInfo.price <= input[pivotIndex].productInfo.price)
        {
            if (ascending)
            {
                subList.Add(input[i]);
            }
            else
            {
                superList.Add(input[i]);
            }
        }
        else if (input[i].productInfo.price > input[pivotIndex].productInfo.price)
        {
            if (ascending)
            {
                superList.Add(input[i]);
            }
            else
            {
                subList.Add(input[i]);
            }
        }
    }

    subArray = subList.ToArray();
    superArray = superList.ToArray();
    subArray = sortPrice(subArray, ascending);
    superArray = sortPrice(superArray, ascending);

    product[] result;
    result = commonClasses.common.appendArray(subArray, input[pivotIndex]);
    result = commonClasses.common.appendArray(result, superArray);

    return result;
}

private static product[] sortStock(product[] input, bool ascending)
{
    if (input.Length <= 1)
    {
        return input;
    }
    else if (input.Length == 2)
    {
        if ((input[0].productInfo.stock > input[1].productInfo.stock && ascending) || (input[0].productInfo.stock < input[1].productInfo.stock && !ascending))
        {
            product temp = input[0];
            input[0] = input[1];
            input[1] = temp;
        }
        return input;
    }

    product[] subArray;
    List<product> subList = new List<product>();
    product[] superArray;
    List<product> superList = new List<product>();
    int pivotIndex = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(input.Length) / 2)) - 1;

    for (int i = 0; i < input.Length; i++)
    {
        if (i == pivotIndex)
        {
            continue;
        }
        else if (input[i].productInfo.stock <= input[pivotIndex].productInfo.stock)
        {
            if (ascending)
            {
                subList.Add(input[i]);
            }
            else
            {
                superList.Add(input[i]);
            }
        }
        else if (input[i].productInfo.stock > input[pivotIndex].productInfo.stock)
        {
            if (ascending)
            {
                superList.Add(input[i]);
            }
            else
            {
                subList.Add(input[i]);
            }
        }
    }

    subArray = subList.ToArray();
    superArray = superList.ToArray();
    subArray = sortStock(subArray, ascending);
    superArray = sortStock(superArray, ascending);

    product[] result;
    result = commonClasses.common.appendArray(subArray, input[pivotIndex]);
    result = commonClasses.common.appendArray(result, superArray);

    return result;
}

private static product[] sortBand(product[] input, bool ascending)
{
    if (input.Length <= 1)
    {
        return input;
    }
    else if (input.Length == 2)
    {
        if ((input[0].productInfo.band.CompareTo(input[1].productInfo.band) > 0 && ascending) || (input[0].productInfo.band.CompareTo(input[1].productInfo.band) < 0 && !ascending))
        {
            product temp = input[0];
            input[0] = input[1];
            input[1] = temp;
        }
        return input;
    }

    product[] subArray;
    List<product> subList = new List<product>();
    product[] superArray;
    List<product> superList = new List<product>();
    int pivotIndex = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(input.Length) / 2)) - 1;

    for (int i = 0; i < input.Length; i++)
    {
        if (i == pivotIndex)
        {
            continue;
        }
        else if (input[i].productInfo.band.CompareTo(input[pivotIndex].productInfo.band) <= 0)
        {
            if (ascending)
            {
                subList.Add(input[i]);
            }
            else
            {
                superList.Add(input[i]);
            }
        }
        else if (input[i].productInfo.band.CompareTo(input[pivotIndex].productInfo.band) > 0)
        {
            if (ascending)
            {
                superList.Add(input[i]);
            }
            else
            {
                subList.Add(input[i]);
            }
        }
    }

    subArray = subList.ToArray();
    superArray = superList.ToArray();
    subArray = sortName(subArray, ascending);
    superArray = sortName(superArray, ascending);

    product[] result;
    result = commonClasses.common.appendArray(subArray, input[pivotIndex]);
    result = commonClasses.common.appendArray(result, superArray);

    return result;
}

private static product[] sortName(product[] input, bool ascending)
{
    if (input.Length <= 1)
    {
        return input;
    }
    else if (input.Length == 2)
    {
        if ((input[0].productInfo.displayName.CompareTo(input[1].productInfo.displayName) > 0 && ascending) || (input[0].productInfo.displayName.CompareTo(input[1].productInfo.displayName) < 0 && !ascending))
        {
            product temp = input[0];
            input[0] = input[1];
            input[1] = temp;
        }
        return input;
    }

    product[] subArray;
    List<product> subList = new List<product>();
    product[] superArray;
    List<product> superList = new List<product>();
    int pivotIndex = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(input.Length) / 2)) - 1;

    for (int i = 0; i < input.Length; i++)
    {
        if (i == pivotIndex)
        {
            continue;
        }
        else if (input[i].productInfo.displayName.CompareTo(input[pivotIndex].productInfo.displayName) <= 0)
        {
            if (ascending)
            {
                subList.Add(input[i]);
            }
            else
            {
                superList.Add(input[i]);
            }
        }
        else if (input[i].productInfo.displayName.CompareTo(input[pivotIndex].productInfo.displayName) > 0)
        {
            if (ascending)
            {
                superList.Add(input[i]);
            }
            else
            {
                subList.Add(input[i]);
            }
        }
    }

    subArray = subList.ToArray();
    superArray = superList.ToArray();
    subArray = sortName(subArray, ascending);
    superArray = sortName(superArray, ascending);

    product[] result;
    result = commonClasses.common.appendArray(subArray, input[pivotIndex]);
    result = commonClasses.common.appendArray(result, superArray);

    return result;
}
    \end{lstlisting}
    I am going to explain the central method and genericize the four sort methods since they are identical, but compare different fields.
    It should be noted that in order to compare strings, I have used the string.CompareTo() method, which returns 1 if the string provided comes before the string the method is called from in the alphabet.
    \begin{itemize}
        \item \textbf{sort} is the method which manages all the other methods.
        It takes a boolean which dictates whether to sort by ascending or descending (true for ascending and false for descending) and a string which represent the sort type.
        The string would do well to be replaced by an enumerator which would mean only a handful of options could be picked and enforced, as opposed to my current solution which just throws an exception if the contents of the string is not recognised as a sort type.
        The body of this method is a switch which determines what to sort by, and calls the appropriate method to sort the working list.
        \item \textbf{Individual Sorts} These are the four methods which actually contain the quicksort logic:
        \begin{itemize}
            \item sortPrice
            \item sortStock
            \item sortBand
            \item sortName
        \end{itemize}
        Each method takes two parameters, the ascending/descending bool and the product[] list to be sorted.
        The main method calls them using the bool that it itself was passed, and points them at the working list.
        Each one contains an almost line-by-line accurate implementation of the quicksort algorithm I outlined in the algorithms section; with the addition of a check whether or not to sort by ascending inserted into the main comparison logic.
        In other words, I have added an extra "else if" to check which list to add the current element to depending on the ascending bool.
    \end{itemize}
    \paragraph{Filtering}
    The code for filtering is much shorter as all that is needed is a for loop that goes through each element and checks if it needs removing or not.
    As such, there is only one filter function which, similarly to the sort() method, contains a switch which dictates what to filter by.
    \begin{lstlisting}[language=C]
public void filter(string field, string value, bool whitelist)
{
    List<product> filteredList = new List<product>();
    int filteredIndex = 0;
    switch (field)
    {
        case "productName":
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].productInfo.displayName.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].productInfo.displayName.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            WorkingList = filteredList.ToArray();
            break;
        case "band":
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].productInfo.band.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].productInfo.band.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            WorkingList = filteredList.ToArray();
            break;

        case "type":
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].productInfo.type.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].productInfo.type.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            WorkingList = filteredList.ToArray();
            break;
        default:
            throw new ArgumentException("The filter field must be one of the specified values");
    }
}
    \end{lstlisting}
    Within this code, there are multiple if statements apparently needlessly repeated since they all do essentially the same thing, just to different fields.
    This is indeed an inefficient solution but there doesn't appear to be any alternative.
    Revisions will probably follow.
    \\
    The \textbf{filter} method takes two strings, one for the field and one for the value to search for, and a boolean which dictates whether it it whitelisting or blacklisting (true for whitelist, false for blacklist).
    It initializes a List class of type product and uses a switch to determine what code to execute, depending on the value of the field string passed to the method.
    Within each case, a for loop runs which goes through element by element; within that for loop is an if statement checking whether or not we are whitelisting and within each of those code which adds the current value to the earlier initialized list depending on whether it matches the search or it doesn't (according to the whitelist/blacklist).
    At the end of the for loop, the working list is set to the output of List.ToArray() which is explained earlier.
    \begin{lstlisting}[language=C]
public void removeOutOfStock()
{
    List<product> filteredList = new List<product>();
    int filteredIndex = 0;
    for (int i = 0; i < masterList.Length; i++)
    {
        if (masterList[i].productInfo.stock > 0)
        {
            filteredList.Add(masterList[i]);
            filteredIndex++;
        }
    }
    WorkingList = filteredList.ToArray();
}
}
    \end{lstlisting}
    This last piece of code is still designed for filtering but exists as it's own method because it is more convenient.
    The method simply makes a new list and adds all the objects from the masterlist which are not out of stock using a for loop, converts it to an array and sets that to be the working list.
    \newpage
    \paragraph{Revision 18/04/18}
    I have made multiple changes to the product handling code since writing this annotation.
    \begin{enumerate}
        \item I have completely removed productStruct as it served little purpose but to be a slave to product.
        All code which references productStruct can easily be either deleted or modified by just removing the ".productInfo" from "product.productInfo.field".
        Instead, the product class now just contains all the information as individual properties, the code initializing a productStruct in product has been replaced with this:
        \begin{lstlisting}[language=C]
public readonly string productName;
public readonly string displayName;
private int Stock;
public int stock { get { return Stock; } }
public readonly decimal price;
public readonly string band;
public readonly string description;
public readonly string imagePath;
public readonly string type;
public int newStock { get; set; }
        \end{lstlisting}
        These are all the needed variables for the product just as they were in productStruct but on their own.
        Stock needs to be written to in some code within the class so I have created the variable "Stock" alongside the property "stock" which allows outside code to view it but not edit while still retaining that functionality for inside code.
        \item In the "sort" and "filter" methods, I have implemented what I described above; the switches now rely on an enum instead of a string which means the default case can be removed.
        The relevant code:
        \begin{lstlisting}[language=C]
public enum sortType { name,band,stock,price }
public enum filterType { name,band,type }

public void sort(bool ascending, sortType type)
{
    switch (type)
    {
        case sortType.price:
            WorkingList = sortPrice(WorkingList, ascending);
            break;
        case sortType.stock:
            WorkingList = sortStock(WorkingList, ascending);
            break;
        case sortType.name:
            WorkingList = sortName(WorkingList, ascending);
            break;
        case sortType.band:
            WorkingList = sortBand(WorkingList, ascending);
            break;
    }
}

public void filter(filterType field, string value, bool whitelist)
{
    List<product> filteredList = new List<product>();
    int filteredIndex = 0;
    switch (field)
    {
        case filterType.name:
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].displayName.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].displayName.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            break;
        case filterType.band:
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].band.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].band.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            break;

        case filterType.type:
            for (int i = 0; i < masterList.Length; i++)
            {
                if (whitelist)
                {
                    if (masterList[i].type.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (masterList[i].type.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(masterList[i]);
                        filteredIndex++;
                    }
                }
            }
            break;
    }
    WorkingList = filteredList.ToArray();
}
        \end{lstlisting}
        \item I refactored the "filter" method.
        I moved the for loop out of the switch to shorten the code and moved the statement that sent the final list to the working list outside also.
        Furthermore, I changed the filter to get it's source information from the working list instead of the master list.
        This is good because it means multiple filters can be applied, without resetting the last one as it would have done before.
        The new code:
        \begin{lstlisting}[language=C]
public void filter(filterType field, string value, bool whitelist)
{
    List<product> filteredList = new List<product>();
    int filteredIndex = 0;
    for (int i = 0; i < WorkingList.Length; i++)
    {
        switch (field)
        {
            case filterType.name:
                if (whitelist)
                {
                    if (WorkingList[i].displayName.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (WorkingList[i].displayName.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                break;
            case filterType.band:
                if (whitelist)
                {
                    if (WorkingList[i].band.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (WorkingList[i].band.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                break;
            case filterType.type:
                if (whitelist)
                {
                    if (WorkingList[i].type.ToUpper() == value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                else
                {
                    if (WorkingList[i].type.ToUpper() != value.ToUpper())
                    {
                        filteredList.Add(WorkingList[i]);
                        filteredIndex++;
                    }
                }
                break;
        }
    }
    WorkingList = filteredList.ToArray();
}
        \end{lstlisting}
        \item (Added after the above) I have discovered a way to refer to a property of a class in C\#.
        This is \textit{indispensable} because it means I can completely refactor the sorting and filtering code.
        Note that I reverted to using the strings and switches method, I found I needed it this way in another page.
        The sorting methods can now only be 95 lines without losing any functionality:
        \begin{lstlisting}[language=C]
public void sort(bool ascending, string type)
{
    Func<product, IComparable> referrer = null;
    switch (type)
    {
        case "price":
            referrer = x => x.price;
            break;
        case "stock":
            referrer = x => x.stock;
            break;
        case "name":
            referrer = x => x.displayName;
            break;
        case "band":
            referrer = x => x.band;
            break;
    }
    WorkingList = quicksort(WorkingList);


    product[] quicksort(product[] input)
    {
        if (input.Length <= 1)
        {
            return input;
        }
        else if (input.Length == 2)
        {
            if (referrer(input[0]).CompareTo(referrer(input[1])) > 0 && ascending || (referrer(input[0]).CompareTo(referrer(input[1])) < 0) && !ascending)
            {
                product temp = input[0];
                input[0] = input[1];
                input[1] = temp;
            }
        }

        product[] subArray;
        List<product> subList = new List<product>();
        product[] superArray;
        List<product> superList = new List<product>();
        int pivotIndex = Convert.ToInt32(Math.Ceiling(Convert.ToDouble(input.Length) / 2)) - 1;

        for (int i = 0; i < input.Length; i++)
        {
            if (i == pivotIndex)
            {
                continue;
            }
            else if (referrer(input[0]).CompareTo(referrer(input[1])) < 0)
            {
                if (ascending)
                {
                    subList.Add(input[i]);
                }
                else
                {
                    superList.Add(input[i]);
                }
            }
            else if (referrer(input[0]).CompareTo(referrer(input[1])) > 0)
            {
                if (ascending)
                {
                    superList.Add(input[i]);
                }
                else
                {
                    subList.Add(input[i]);
                }
            }
        }

        subArray = subList.ToArray();
        superArray = superList.ToArray();
        subArray = quicksort(subArray);
        superArray = quicksort(superArray);

        product[] result;
        result = commonClasses.common.appendArray(subArray, input[pivotIndex]);
        result = commonClasses.common.appendArray(result, superArray);

        return result;
    }
}
        \end{lstlisting}
        There are many changes in the above code.
        The first is that I have compacted all the sorting methods into one method, then nested it inside the "sort" method.
        The advantage of nesting is that the method no longer needs to be called with ascending because it already has access to it from it's parent method.
        \textbf{Func$<$product, IComparable$>$} is the major breakthrough in this revision - this allows me to set a dynamic reference to any property (of a type which inherits from the interface IComparable) of product that I want.
        I can set it to any property of product, then calling "referrer(product1).CompareTo(product2)" will return an integer; if it is 0 the two are equal, if above 0 product1's property is bigger than product2's and if below 0 it is smaller.
        Replacing the appropriate lines in the new quicksort function with this but replacing product1 and product2 with the items being compared makes the function perfectly generic and a good example of abstracted code.
        \begin{lstlisting}[language=C]
public void filter(string field, string value, bool whitelist)
{
    List<product> filteredList = new List<product>();
    Func<product, string> referrer = null;
    int filteredIndex = 0;
    switch (field)
    {
        case "productName":
            referrer = x => x.productName;
            break;
        case "band":
            referrer = x => x.band;
            break;
        case "type":
            referrer = x => x.type;
            break;
    }
    for (int i = 0; i < WorkingList.Length; i++)
    {
        if (whitelist)
        {
            if (referrer(WorkingList[i]).ToUpper() == value.ToUpper())
            {
                filteredList.Add(WorkingList[i]);
                filteredIndex++;
            }
        }
        else
        {
            if (referrer(WorkingList[i]).ToUpper() != value.ToUpper())
            {
                filteredList.Add(WorkingList[i]);
                filteredIndex++;
            }
        }
    }
    WorkingList = filteredList.ToArray();
}
        \end{lstlisting}
        I have overhauled the filtering logic as well to use a similar method with \textbf{Func$<$product, string$>$} which does the same as above but will only operate on properties that are of type string, which I can do because the filter class only needs to operate on strings.
    \end{enumerate}
    \newpage
    \subsubsection{Store Front Page}
    The store front page is the heart of my application.
    The C\# code is as follows:
    \begin{lstlisting}[language=C]
productList productsDisplayList;
Panel[] panels;
bool initialized = false;

protected void Page_Load(object sender, EventArgs e)
{
    if (initialized)
    {
        populatePage();
    }
    else
    {
        productsDisplayList = new productList();
        populatePage();
        initialized = true;
    }
}

private void populatePage()
{
    panels = productsDisplayList.generateControls();
    productsListPanel.Controls.Clear();
    for (int i = 0; i < panels.Length; i++)
    {
        Button detailsButton = new Button()
        {
            CssClass = "detailsButton",
            Text = "View",
            ID = productsDisplayList.list[i].productName + "DetailsLinkButton",
            CommandArgument = productsDisplayList.list[i].productName
        };
        detailsButton.Click += new EventHandler(detailsButton_Click);
        detailsButton.Attributes.Add("runat", "server");
        panels[i].Controls.Add(detailsButton);
        productsListPanel.Controls.Add(panels[i]);
    }
}

protected void detailsButton_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    Session["productRedirectName"] = btn.CommandArgument;
    Server.Transfer("~/productView.aspx", false);
}

protected void startSortButton_Click(object sender, EventArgs e)
{
    bool ascending;
    if (sortType.SelectedIndex == 0)
    {
        ascending = true;
    }
    else
    {
        ascending = false;
    }
    productsDisplayList.sort(ascending, sortField.SelectedValue);
    populatePage();
}

protected void searchButton_Click(object sender, EventArgs e)
{
    string searchType = searchFieldDropdown.SelectedValue;
    string searchText = searchBox.Text;
    bool whitelist = Convert.ToBoolean(whitelistSelect.SelectedValue);
    productsDisplayList.filter(searchType, searchBox.Text, whitelist);
    populatePage();
}

protected void coasterClockButton_Click(object sender, EventArgs e)
{
    string filterMode = coastersOrClocks.SelectedValue;
    productsDisplayList.filter("stock", filterMode, true);
    populatePage();
}

protected void resetFilter_Click(object sender, EventArgs e)
{
    productsDisplayList.resetWorkingList();
    populatePage();
}
    \end{lstlisting}
    \paragraph{The Page}
    The page contains a panel full of various controls for filtering and sorting the contents of the page and an empty panel in the content called productsDisplayPanel.
    It inherits from Customer.Master.
    \paragraph{The Code}
    The variables on this page are:
    \begin{itemize}
        \item \textbf{productsDisplayList} is the local productList instance.
        It stores all the products which were in the database when the page was first loaded and contains all the logic and code which was detailed above.
        \item \textbf{panels} is the array which will hold all the productPanels the page is currently operating on.
        This does not store all the panels currently rendered on the page, as I cannot find a way to do that in C\# and ASP.NET.
        The array that contains those is this.Controls[] which also holds the rest of the controls on the page.
        \item \textbf{initialized} is a boolean value which just states if the page has already been loaded for the first time by the user.
        It is used to ensure that the database is not access more than it has to be by ensuring that productsDisplayList is not initialized again every time the page refreshes.
        This in turn ensures that productsDisplayList is consistent across page refreshes which is important to retain the sort and filter.
    \end{itemize}
    The methods within this page are as follows:
    \begin{itemize}
        \item \textbf{Page\_Load} here just checks if initialized is true.
        If it is, it will just run populatePage() and if not it will instantiate a new instance of productsDisplayList, then run populatePage() and set initialized to true so this iteration does not trigger twice in a row.
        \item \textbf{populatePage} generates all the needed controls and adds them to the Controls[] property of productsListPanel.
        It starts by setting panels[] to the output of productsDisplayList.generateControls() which is detailed in the productsList documentation so panels is now just an array of productPanels.
        It clears out the already existing controls in productsListPanel to make way for the new ones it is generating.
        It runs a for loop which goes through each panel in panel because for this page only, we need a button to be generated with each panel which will take the user to the individual product view page; within the loop a button (detailsButton) is initialized.
        The appropriate properties of the button are set:
        \begin{itemize}
            \item CssClass is set to "detailsButton" to ensure CSS styling is applied to it.
            \item Text is set to "View" to clearly illustrate to the user what the button does.
            \item ID is set to the name of the product appended with "DetailsLinkButton".
            This might seem a little useless, but ASP.NET will throw exceptions if similar objects on the page have the same or no ID.
            \item CommandArgument is set to the name of the product the panel is linked to.
            This determines what parameter is passed to the function that runs when the button is clicked, so that the function of each detailsButton can be unique.
        \end{itemize}
        It instantiates a new EventHandler, which will catch when the button is clicked and execute a method, and points it towards the method detailsButton\_Click.
        It adds the attribute "runat:server" to ensure the control functions as expected with other controls then adds the whole button to the Controls[] list of the whole productPanel that the for loop is currently examining.
        Finally, it adds the whole productPanel to productsDisplayPanel.
        \item \textbf{detailsButton\_Click} is a standard click event method.
        It takes the sender which triggered the event and the arguments of the event contained in the EventArgs instance "e".
        The method gets the button instance which sent it by filtering sender.
        It sets the "productRedirectName" session to the command argument of the button (which as you can see above is the name of the product that button is linked to).
        It then redirects the user to the productView page, which uses the session value to determine what product to show.
        \item \textbf{startSortButton\_Click} is another standard click event.
        startSort is a button in the panel containing all the sorting controls which applies the selected sort.
        The method gets whether the user wants ascending or descending sort by checking which value of the dropdown box sortType is selected.
        It then runs productsDisplayList.sort and passes it the selected value of sortField (which dictates what property to sort by) and the ascending bool it obtained earlier.
        When the sort is done running on the list, it runs populatePage to refresh the page and show all the products in their new, sorted form.
        \item \textbf{searchButton\_Click} is another button's click event.
        It pulls the field to search into searchType from searchFieldDropdown and the searchText from searchBox (note that this does not need to be sanitized as it never runs on the database).
        It determines whether or not the user wants a whitelisted search or a blacklisted search from the selected value of whitelistSelect.
        It uses the filter() method of productsDisplayList to filter the list, then regenerates all the controls on the page using populatePage.
        \item \textbf{resetFilter\_Click} is the final method for this page.
        It is the button click event of the final button on the page which simply runs resetWorkingList on productsDisplayList to clear all sorts and filters, then runs populatePage to update the actual webpage.
    \end{itemize}
    \newpage
    \subsubsection{Individual Product Page}
    This is the page the user sees when they click the button labelled "View" on the store front page.
    It contains a larger version of the image of the product and a description.
    \begin{lstlisting}[language=C]
product currentProduct;
defaultDataSetTableAdapters.cartsTableAdapter cartsAdaptor = new defaultDataSetTableAdapters.cartsTableAdapter();

protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToString(Session["productRedirectName"]) == null || Convert.ToString(Session["productRedirectName"]) == "")
    {
        Server.Transfer("~/products.aspx", false);
    }
    currentProduct = new product(Convert.ToString(Session["productRedirectName"]));
    productPanel currentPanel = new productPanel(currentProduct);
    currentPanel.CssClass = "fullProductPanel";
    product.Controls.Add(toAdd);
}

protected void cartButton_Click(object sender, EventArgs e)
{
    if (Convert.ToString(Session["userType"]) != "customer")
    {
        returnLabel.Text = "You must log in to a customer account to have a cart!";
    }
    else
    {
        if (amountToAdd.Text != "0")
        {
            if (cartsAdaptor.checkExisting(Convert.ToString(Session["currentUser"]), currentProduct.productName) == null)
            {
                cartsAdaptor.insertProduct(Convert.ToString(Session["currentUser"]), currentProduct.productName, Convert.ToInt32(amountToAdd.Text));
            }
            else
            {
                cartsAdaptor.updateAmount(Convert.ToInt32(amountToAdd.Text), Convert.ToString(Session["currentUser"]), currentProduct.productName);
            }
            returnLabel.Text = amountToAdd.Text + " " + currentProduct.productName + "s added to your cart!";
        }
        else
        {
            returnLabel.Text = "You can't add 0 of something to your cart!";
        }
    }
}
    \end{lstlisting}
    The page is contains a panel called "product" to drop the productPanel into, a textbox for them to enter the amount of the product they want to add to their cart and a button to actually add it to their cart.
    The variables on the page are:
    \begin{itemize}
        \item \textbf{currentProduct} is the instance of product the page is basing itself off.
        \item \textbf{cartsAdaptor} is the adaptor for the carts table, which the page needs because it needs to add products to the carts table.
    \end{itemize}
    The methods on the page are:
    \begin{itemize}
        \item \textbf{Page\_Load} contains code to initialize all the controls which need to be on the page for it to display the product effectively.
        It first checks if the session "productRedirectName" has actually been assigned a value by the store front page, and if not, it redirects the user to the store front page because it can't display a without being instructed which one to show.
        It uses the value of that session to instantiate a new product with the name of the product passed from the session to it's constructor.
        It instantiates a productPanel using the product class and calls it "currentPanel".
        It sets the CssClass property of the panel to "fullProductPanel" so that different styling is applied to it than those on the store front page.
        Finally, it adds the panel to the panel on the page.
        \item \textbf{cartButton\_Click} is the click event for the only button on the page, the "add to cart" button.
        The method initially checks if the user that is currently logged in is a customer, as these are the only accounts that are allowed to have a cart.
        It checks if the amount of the product they're trying to add is 0 and denies them if it is (no check is needed to ensure that the contents of the amountToAdd text box is actually a number because the "TextMode" property of the box is set to "number" so the page will not allow the user to type anything but numbers into it).
        It then uses the adaptor's query checkExisting to check if the customer has already added that product to their cart.
        checkExisting runs:
        \begin{lstlisting}[language=SQL]
SELECT COUNT(*) AS Expr1, [user], productName
FROM carts
GROUP BY [user], productName
HAVING ([user] = ?) AND (productName = ?)
        \end{lstlisting}
        If there isn't that product in the user's cart, then the query insertProduct is used:
        \begin{lstlisting}[language=SQL]
INSERT INTO `carts` (`user`, `productName`, `amount`)
VALUES (?, ?, ?)
        \end{lstlisting}
        in order to add it with the amount the user specified.
        If the product is already in their cart, the query updateStock is run:
        \begin{lstlisting}[language=SQL]
UPDATE carts
SET amount = amount + ?
WHERE ([user] = ?) AND (productName = ?)
        \end{lstlisting}
        At all possible terminations of this process, the user is updated with the status of the operation using returnLabel.
    \end{itemize}
    \paragraph{Revision 29/04/18}
    The huge set of nested if statements in the method "cartButton\_Click" is both difficult to understand and unnecessary.
    I have overhauled them to be in series and just end the method when a failing condition is met.
    \begin{lstlisting}[language=C]
if (Convert.ToString(Session["userType"]) != "customer")
{
    returnLabel.Text = "You must log in to a customer account to have a cart!";
    return;
}
if (amountToAdd.Text == "0")
{
    returnLabel.Text = "You can't add 0 of something to your cart!";
    return;
}

if (cartsAdaptor.checkExisting(Convert.ToString(Session["currentUser"]), currentProduct.productName) == null)
{
    cartsAdaptor.insertProduct(Convert.ToString(Session["currentUser"]), currentProduct.productName, Convert.ToInt32(amountToAdd.Text));
}
else
{
    cartsAdaptor.updateAmount(Convert.ToInt32(amountToAdd.Text), Convert.ToString(Session["currentUser"]), currentProduct.productName);
}
returnLabel.Text = amountToAdd.Text + " " + currentProduct.productName + "s added to your cart!";
    \end{lstlisting}
    \newpage
    \subsubsection{Customer Registration}
    This page is univesally accessible through a link on the customer log in page, as I mentioned in the documentation for that.
    \begin{lstlisting}[language=C]
private defaultDataSetTableAdapters.customersTableAdapter customersQueryTable = new defaultDataSetTableAdapters.customersTableAdapter();
protected void Page_Load(object sender, EventArgs e)
{

}

protected void registerButton_Click(object sender, EventArgs e)
{
    if (passwordBox.Text == confirmPasswordBox.Text)
    {
        int dump;
        if (int.TryParse(phoneNumberBox.Text, out dump))
        {
            if (customSecurity.sanitizeCheck(new string[] { usernameBox.Text, passwordBox.Text, address1Box.Text, address2Box.Text, cityBox.Text, countryDropdown.SelectedValue, postcodeBox.Text, phoneNumberBox.Text, forenameBox.Text, surnameBox.Text }))
            {
                try
                {
                    customersQueryTable.newCustomer(usernameBox.Text, customSecurity.generateMD5(passwordBox.Text), address1Box.Text, address2Box.Text, cityBox.Text, countryDropdown.SelectedValue, postcodeBox.Text, phoneNumberBox.Text, forenameBox.Text, surnameBox.Text);
                    customLogging.newEntry("Someone registered the user " + usernameBox.Text);
                    returnLabel.Text = "User " + usernameBox.Text + " created";
                }
                catch (Exception except)
                {
                    returnLabel.Text = "Registration failed, reason: " + except.Message;
                }
            }
            else
            {
                returnLabel.Text = customSecurity.sanitizeErrorMessage;
            }
        }
        else
        {
            phoneNumReturn.Text = "The phone number must be digits only!";
        }
    }
    else
    {
        confirmPasswordBox.Text = "";
        passwordBoxReturn.Text = "The passwords don't match!";
    }
}

protected void confirmPasswordBox_TextChanged(object sender, EventArgs e)
{
    passwordsMatchCheck();
}

protected void passwordBox_TextChanged(object sender, EventArgs e)
{
    passwordsMatchCheck();
}

private void passwordsMatchCheck()
{
    if (passwordBox.Text != confirmPasswordBox.Text)
    {
        passwordBoxReturn.Text = "The passwords don't match!";
    }
}
    \end{lstlisting}
    \paragraph{The Page}
    On the page there are text boxes for:
    \begin{itemize}
        \item Username
        \item Password
        \item Confimation of Password (to reduce the chances the user types the wrong password in since both boxes are set to not show their contents)
        \item First Name
        \item Surname
        \item Address Line 1
        \item Address Line 2
        \item Town/City
        \item Post Code
        \item Phone Number
    \end{itemize}
    Additionally, there is a dropdown box for the user to pick a country from, two labels to show messages to the user and a button to submit the details ggiven.
    \paragraph{The Code}
    The only variable on the page is \textbf{customersQueryTable}, which serves the same purpose as adaptor on other pages.
    It is the DataSet adaptor for the customers table in the database and manage all queries to be run on that table.
    \\
    The methods on the page are:
    \begin{itemize}
        \item \textbf{Page\_Load} serves no purpose in this page because nothing needs to happen on the page when it loads.
        \item \textbf{registerButton\_Click} performs a series of checks on the contents of the boxes before inserting the information into the database using a set of if statements.
        The checks it performs are:
        \begin{itemize}
            \item Whether the password box and confirm password boxes' contents match.
            If they don't, the process is cancelled and the relevant return label shows an appropriate message.
            \item If the phone number actually parses as an integer.
            This is necessary because I can't set the text mode of the phone number text box to "number", because it will then remove 0s from the beginning and other related things.
            \item A sanitize check with customSecurity.sanitizeCheck() to ensure all boxes are free of SQL sensitive characters.
            All these boxes' contents will be inserted into the database, so this is necessary to prevent SQL injection.
        \end{itemize}
        Once all these checks are complete, a try-catch statement is used to run the necessary query on the database.
        I enclosed the database query like this because when I wrote this I wasn't sure whether or not to expect any errors but I will likely revise it.
        The query run is:
        \begin{lstlisting}[language=SQL]
INSERT INTO customers (username, [password], addressLine1, adressLine2, city, country, postCode, phoneNumber, forename, surname)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        \end{lstlisting}
        This simply adds values to all the new required fields.
        The creation is logged, and the return label is appropriately updated with a message.
    \end{itemize}
    \paragraph{Revision 05/05/18}
    I decided the horrendous set of nested if statements could easily be reorganised and that the try-catch statement could be removed since the code isn't likely to throw exceptions.
    \textbf{registerButton\_Click} now contains:
    \begin{lstlisting}[language=C]
if (passwordBox.Text != confirmPasswordBox.Text)
{
    confirmPasswordBox.Text = "";
    passwordBoxReturn.Text = "The passwords don't match!";
    return;
}

int dump;
if (!int.TryParse(phoneNumberBox.Text, out dump))
{
    phoneNumReturn.Text = "The phone number must be digits only!";
    return;
}

if(!customSecurity.sanitizeCheck(new string[] { usernameBox.Text, passwordBox.Text, address1Box.Text, address2Box.Text, cityBox.Text, countryDropdown.SelectedValue, postcodeBox.Text, phoneNumberBox.Text, forenameBox.Text, surnameBox.Text }))
{
    returnLabel.Text = customSecurity.sanitizeErrorMessage;
    return;
}

customersQueryTable.newCustomer(usernameBox.Text, customSecurity.generateMD5(passwordBox.Text), address1Box.Text, address2Box.Text, cityBox.Text, countryDropdown.SelectedValue, postcodeBox.Text, phoneNumberBox.Text, forenameBox.Text, surnameBox.Text);
customLogging.newEntry("Someone registered the user " + usernameBox.Text);
returnLabel.Text = "User " + usernameBox.Text + " created";
    \end{lstlisting}
    \newpage
    \subsubsection{Cart Page}
    This page shows the user what is in their cart, and gives them the option to edit it.
    \begin{lstlisting}[language=C]
struct cartItem
{
    public product product;
    public int amount;
}

defaultDataSetTableAdapters.cartsTableAdapter cartsTableAdapter = new defaultDataSetTableAdapters.cartsTableAdapter();
cartItem[] cartArray;

protected void Page_Load(object sender, EventArgs e)
{
    populateList();
    if (cartArray.Length == 0)
    {
        productsListPanel.Controls.Add
            (
                new Label()
                {
                    Text = "Your cart is empty!",
                    CssClass = "cartEmptyMessage"
                }
            );
        purchaseButton.Visible = false;
    }
    else
    {
        populatePage();
        purchaseButton.Visible = true;
    }
}

private void populateList()
{
    using (DataTable temp = cartsTableAdapter.getCart(Convert.ToString(Session["currentUser"])))
    {
        cartArray = new cartItem[temp.Rows.Count];
        int i = 0;
        foreach (DataRow row in temp.Rows)
        {
            cartArray[i].product = new product(Convert.ToString(row[2]));
            cartArray[i].amount = Convert.ToInt32(row[3]);
            i++;
        }
    }
}

private void populatePage()
{
    foreach(cartItem current in cartArray)
    {
        productPanel panel = new productPanel(current.product);
        panel.Controls.Remove(panel.Controls[3]);
        panel.Controls.Remove(panel.Controls[3]);

        TextBox amountBox = new TextBox()
        {
            CssClass = "amountBox",
            ID = current.product.productName + "_CartAmountBox",
            Text = Convert.ToString(current.amount),
            TextMode = TextBoxMode.Number,
            AutoPostBack = true
        };
        amountBox.TextChanged += new EventHandler(amountBox_TextChanged);
        panel.Controls.Add(amountBox);

        Button removeButton = new Button()
        {
            CssClass = "removeButton",
            ID = current.product.productName + "_CartRemoveButton",
            Text = "Remove",
            CommandArgument = current.product.productName
        };
        removeButton.Click += new EventHandler(removeButton_Click);
        removeButton.Attributes.Add("runat", "server");
        panel.Controls.Add(removeButton);

        panel.CssClass = "cartProductDisplayPanel";
        productsListPanel.Controls.Add(panel);
    }
}

protected void removeButton_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    int i = 0;
    int index = 0;
    foreach (cartItem current in cartArray)
    {
        if (current.product.productName == productName)
        {
            index = i;
        }
        i++;
    }
    var temp = new List<cartItem>(cartArray);
    temp.RemoveAt(index);
    cartArray = temp.ToArray();
    populatePage();
}

protected void amountBox_TextChanged(object sender, EventArgs e)
{
    TextBox box = (TextBox)sender;
    string productName = box.ID.Split('_')[0];
    int i = 0;
    int index = 0;
    foreach(cartItem current in cartArray)
    {
        if (current.product.productName == productName)
        {
            index = i;
            break;
        }
        i++;
    }
    cartArray[index].amount = Convert.ToInt32(box.Text);
}

protected void purchaseButton_Click(object sender, EventArgs e)
{
    makeOrder();
}

protected void makeOrder()
{
    var productsAdaptor = new defaultDataSetTableAdapters.productsTableAdapter();
    var ordersAdaptor = new defaultDataSetTableAdapters.ordersTableAdapter();
    if (Convert.ToString(Session["userType"]) != "customer")
    {
        returnLabel.Text = "You're not a registered customer so you can't make an order!";
        return;
    }
    foreach (cartItem current in cartArray)
    {
        int currentStock = Convert.ToInt32(productsAdaptor.getStock(current.product.productName));
        if (currentStock < current.amount)
        {
            returnLabel.Text = "Sorry, we only have " + currentStock + " of " + current.product.productName + " in stock!";
            return;
        }
    }
    commonClasses.customLogging.newEntry("Customer " + Convert.ToString(Session["currentUser"]) + " checked out");
    foreach (cartItem current in cartArray)
    {
        ordersAdaptor.newOrder(DateTime.Now, current.product.price * current.amount, current.amount, Convert.ToString(Session["currentUser"]), current.product.productName);
        productsAdaptor.updateStock(Convert.ToInt32(productsAdaptor.getStock(current.product.productName)) - current.amount, current.product.productName);
    }
    cartsTableAdapter.deleteCart(Convert.ToString(Session["CurrentUser"]));
    populateList();
    populatePage();
    returnLabel.Text = "Thanks for your order!";
}
    \end{lstlisting}
    \paragraph{The Page}
    The page contains a panel to place all the programmatically generated panels into, a button for the user to purchase the contents of their cart and a label for returning messages to the user.
    \paragraph{The Code}
    The variables and properties in this page's C\# code are:
    \begin{itemize}
        \item \textbf{cartItem} is a customer structure which I have declared to help me store items in the cart for the purposes of the page.
        Since productList doesn't contain functionality for multiple amounts of an item within the list and it's general design is that of showing the products in stock, not a seperate collection, I made this singularly for the purposes of this page.
        It stores an instance of "product" and a integer representing the amount of that product.
        It is intended to be used to create an array.
        \item \textbf{cartsTableAdapter} is just an instance of the adaptor to hold queries which will need to be executed on the "carts" table in the database.
        \item \textbf{cartArray} is the array of type cartItem which will serve as the local list of all the items in the user's cart.
    \end{itemize}
    The methods are:
    \begin{itemize}
        \item \textbf{Page\_Load} first runs populateList() to pull the relevant contents of the carts table into cartArray.
        It then checks if the cartArray object is empty (ie. it's length is 0, meaning the user has no items in their cart).
        If it is, a label is generated then added to the page to inform the user that there are no products in their cart.
        If it isn't, populatePage() is run to generate all the elements which the page needs and the purchase button (which is invisible by default) is set to be visible.
        \item \textbf{populateList} uses the query getCart in cartsTableAdapter to get a complete list of all the records in the table.
        The query is a simple get all:
        \begin{lstlisting}[language=SQL]
SELECT ID, [user], productName, amount FROM carts
        \end{lstlisting}
        Once the method has the table, it initializes cartArray using the amount of rows in the table as the amount of elements to initialize, and an integer to serve as the index of the foreach loop it is about to run.
        A for each loop is run which goes through each row in the DataTable and sets the next element in cartArray to match the correct columns for the name and the amount, using the name to initialize a new product.
        \item \textbf{populatePage} is designed to create all the elements to be displayed on the page.
        All the logic in the method is enclosed in a for each loop which goes through all the elements in cartArray and generates an augmented productPanel for them.
        The code begins by intializing a new instance of productPanel which generates most of the needed elements by itself.
        Immediately after initialization, the code removes the stockTag and descriptionTag because they are both not needed in the design of this page.
        This is accomplished by removing the control at position 3 in the controls array of the productPanel instance twice - since the controls are adjacent, the descriptionTag falls into the place that the stockTag just occupied.
        Then, a new TextBox is created to let the user change the amount of the product they have in their cart and the relevant properties set:
        \begin{itemize}
            \item CssClass is set to amountBox so that styling can be applied
            \item ID is set to the product's name plus "\_CartAmountBox" as this is used later
            \item Text is set to the amount registered of the product because this textbox should start with displaying the amount of the product which is in the cart
            \item TextMode is set to be "number" because this will prevent users entering anything but digits, which is what we want for this box
            \item AutoPostback is set to true; postback forces a page refresh and allows the textbox to trigger event handlers when the contents is changed and the return key is pressed
        \end{itemize}
        The new TextBox has a new EventHandler assigned to it which will trigger \textbf{amountBox\_TextChanged} when the text is changed.
        The control is added to the controls of the current productPanel.
        \\
        A new button is instantiated to let the user remove something from their cart with the following properties:
        \begin{itemize}
            \item CssClass is set to "amountBox" to allow styling
            \item ID is set to the name of the current product plus "\_CartRemoveButton" so that the control can be referred to later on
            \item Text is set to remove to indicate the button's purpose to the user
            \item The CommandArgument of the button is set to the name of the product so that the button functions per product
        \end{itemize}
        An EventHandler is added to the button's click hook and assigned the method "removeButton\_Click".
        The attribute "runat:server" is added to the button so that it functions correctly within ASP.
        The button is added to the panel's control list.
        Finally, the panel itself has it's CssClass changed to "cartProductDisplayPanel" so that individual styling can be applied to it with no effect from the styling applied to productPanel by default and it is added to the panel on the page which is set aside for it.
        \item \textbf{removeButton\_Click} runs when the remove button is clicked.
        It gets the button which ran the method by filtering the sender by type "Button" and gets the name of the product whose remove button was clicked from the ID of the button (Ideally this would be taken from the command argument but at this time that doesn't seem to work) by splitting it using String.Split() at the "\_" character and taking the first part.
        It uses a foreach loop with an externally managed index "i" to set the integer "index" to be the index of that panel within the array holding all the augmented productPanels by matching the names of each to the string it obtained from the button's ID.
        It converts the cartArray to a list temporarily so that removing items is much easier, and removes the element at the previously found index.
        The list is converted back to an array and set to cartArray, and populatePage() is run to show the new information on the page.
        \item \textbf{amountBox\_TextChanged} runs when the value inside amountBox is changed and the return key is pressed.
        As before, the method obtains the sender and the name of the product in question from the attributes of the sender by splitting the ID.
        Again, a for each loop is run with a manual "i" to find the index of the product in cartArray.
        Once these pieces of information are found, the .amount property of the correct element in cartArray is changed to the user's new desired amount.
        \item \textbf{purchaseButton\_Click} effectively just runs makeOrder.
        This is in it's own method because this is a dummy - if the project were to actually be deployed, then much different code would go here.
        \item \textbf{makeOrder} begins by opening two new adaptors because access to the products table and the orders table are needed for the customer to actually purchase their items.
        The method checks that the logged in user is actually a customer by checking that the "userType" session is "customer" and returns an appropriate message explaining that they cannot make an order if they aren't.
        Then, a foreach loop is run to check that there is actually enough of each product in the cart in stock to satisfy the customer's order - an integer is obtained from the output of the getStock query:
        \begin{lstlisting}[language=SQL]
SELECT stock
FROM products
WHERE (productName = ?)
        \end{lstlisting}
        If the amount of the product the user is trying to buy is more than the amount of the product available, the operation is cancelled and the user is notified with the return label.
        Once the above checks are complete, the purchase can be "made".
        First, the purchase is logged - the names of the products bought/their amounts are not needed in the log since they are stored in the orders table.
        Then, for each item in the cart, two queries are run - the newOrder query on the orders table:
        \begin{lstlisting}[language=SQL]
INSERT INTO `orders` (`datePlaced`, `spent`, `productAmount`, `customer`, `product`)
VALUES (?, ?, ?, ?, ?)
        \end{lstlisting}
        Which creates a new order with the correct information which is calculated on the spot.
        The other query is the updateStock query for the products table so that the correct amount of stock is removed to represent the customer's purchase:
        \begin{lstlisting}[language=SQL]
UPDATE products
SET stock = ?
WHERE (productName = ?)
        \end{lstlisting}
        Once these queries have finished for each product, the deleteCart query is run once on the cart table:
        \begin{lstlisting}
DELETE FROM carts
WHERE ([user] = ?)
        \end{lstlisting}
        This just deletes all the cart entries for the user, since they have just purchased them all.
        Finally, populateList is run to refresh the local list (to be blank), populatePage is run to clear the page of all the elements that were on it and the return label is set to display a thank you message.
    \end{itemize}
    \paragraph{Revision 07/05/18}
    Upon re reading this code, I realize now that the amount box doesn't update the amount of the product in the carts table so if the page is refreshed, the new value will be lost.
    I created the following query and called it updateAmount:
    \begin{lstlisting}[language=SQL]
UPDATE carts
SET amount = amount + ?
WHERE ([user] = ?) AND (productName = ?)
    \end{lstlisting}
    And added it to the \textbf{amountBox\_TextChanged} method, at the end:
    \begin{lstlisting}[language=C]
TextBox box = (TextBox)sender;
string productName = box.ID.Split('_')[0];
int newAmount = Convert.ToInt32(box.Text);
int i = 0;
int index = 0;
foreach(cartItem current in cartArray)
{
    if (current.product.productName == productName)
    {
        index = i;
        break;
    }
    i++;
}
cartArray[index].amount = newAmount;
cartsTableAdapter.updateAmount(newAmount, Convert.ToString(Session["currentUser"]), productName);
    \end{lstlisting}
    \newpage
    \subsubsection{Employee Registration}
    The employee registration page is different to the customer registration page because the only people authorized to register a new administrator are administrators.
    Employees may register other, normal employees but not administrators.
    It inherits from the Employee.Master file, so it is only accessible to employees by default.
    This, however, is not enough and so an additional check needs to be put in place for this page only, in Page\_Load.
    \begin{lstlisting}[language=C]
protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToString(Session["userIsAdmin"]) == "False")
    {
        adminCheckBox.Visible = false;
    }
    else
    {
        adminCheckBox.Visible = true;
    }
}

protected void newUser_Click(object sender, EventArgs e)
{
    if (submittedPasswordBox.Text == submittedConfirmPasswordBox.Text)
    {
        if (customSecurity.sanitizeCheck(new string[] { submittedUsernameBox.Text, submittedPasswordBox.Text, forenameBox.Text, surnameBox.Text }))
        {
            if (submittedUsernameBox.Text != "master" || submittedUsernameBox.Text != "Market")
            {
                using (defaultDataSetTableAdapters.employeesTableAdapter employeeQueryTable = new defaultDataSetTableAdapters.employeesTableAdapter())
                {
                    try
                    {
                        employeeQueryTable.newEmployee(submittedUsernameBox.Text, customSecurity.generateMD5(submittedPasswordBox.Text), adminCheckBox.Checked, forenameBox.Text, surnameBox.Text);
                        registerReturn.Text = "New employee created";
                        customLogging.newEntry("Employee " + submittedUsernameBox.Text + " was created");
                    }
                    catch (Exception except)
                    {
                        registerReturn.Text = "Database operation failed with error " + except.Message;
                    }
                }
            }
            else
            {
                registerReturn.Text = "That is a reserved username!";
            }
        }
        else
        {
            registerReturn.Text = customSecurity.sanitizeErrorMessage;
        }
    }
    else
    {
        registerReturn.Text = "The passwords don't match!";
        submittedConfirmPasswordBox.Text = "";
    }
}
    \end{lstlisting}
    \paragraph{The Page}
    The page contains text boxes for:
    \begin{itemize}
        \item The desired Username
        \item The desired password and another box to confirm it
        \item The employee's forename
        \item The employee's surname
    \end{itemize}
    Additionally, there is a checkbox to specify whether or not the new user should be an administrator, a button to submit the form and a label to show the user the result of the operation.
    \paragraph{The Code}
    There are no additional properties on the page.
    The methods are:
    \begin{itemize}
        \item \textbf{Page\_Load} contains a similar check to the employee check present on Employee.Master, but it checks the "userIsAdmin" session instead of the "userType" session.
        If the user is an admin, the administrator checkbox is made visible, and invisible if they are not.
        \item \textbf{newUser\_Click} triggers when the new user button is clicked.
        It contains a series of checks not dissimilar to those that the customer registration page performs.
        The first checks that the two boxes contain the same amount and notifies the user if they don't.
        The second uses customSecurity.sanitizeCheck to ensure there are no SQL-sensitive characters in the textboxes, and returns the standard error message if they are.
        The third checks specifically checks if the username of the account that is being created is trying to be set to "master" or "Market".
        Both of these are reserved for function within the program as master is the default administrator account which cannot be interfered with, and "Market" is the username I am using to reserve items for the market, detailed below.
        Finally, a new adaptor is opened to the employees table and the new account is created with newEmployee:
        \begin{lstlisting}[language=SQL]
INSERT INTO employees (username, [password], admin, forename, surname)
VALUES (?, ?, ?, ?, ?)
        \end{lstlisting}
        The return label shows an appropriate message and the creation of a new employee is logged.
        The last-described logic is enclosed in a try-catch statement should any database errors occur.
    \end{itemize}
    \paragraph{Revision 01/05/18}
    As before, the series of nested if statements in \textbf{newUser\_Click} is an absurd solution here, and makes the code much more difficult to read.
    I have amended as below:
    \begin{lstlisting}[language=C]
if (submittedPasswordBox.Text != submittedConfirmPasswordBox.Text)
{
    registerReturn.Text = "The passwords don't match!";
    submittedConfirmPasswordBox.Text = "";
}

if (!customSecurity.sanitizeCheck(new string[] { submittedUsernameBox.Text, submittedPasswordBox.Text, forenameBox.Text, surnameBox.Text }))
{
    registerReturn.Text = customSecurity.sanitizeErrorMessage;
}

if (submittedUsernameBox.Text == "master" || submittedUsernameBox.Text == "Market")
{
    registerReturn.Text = "That is a reserved username!";
}

using (defaultDataSetTableAdapters.employeesTableAdapter employeeQueryTable = new defaultDataSetTableAdapters.employeesTableAdapter())
{
    try
    {
        employeeQueryTable.newEmployee(submittedUsernameBox.Text, customSecurity.generateMD5(submittedPasswordBox.Text), adminCheckBox.Checked, forenameBox.Text, surnameBox.Text);
        registerReturn.Text = "New employee created";
        customLogging.newEntry("Employee " + submittedUsernameBox.Text + " was created");
    }
    catch (Exception except)
    {
        registerReturn.Text = "Database operation failed with error " + except.Message;
    }
}
    \end{lstlisting}
    \newpage
    \subsubsection{User Management Page}
    This page allows employees to see and change information and credentials of users (both employees and customers), and administrators to delete them.
    It inherits from Employee.Master.
    \begin{lstlisting}[language=C]
defaultDataSetTableAdapters.employeesTableAdapter employeeQueryTable = new defaultDataSetTableAdapters.employeesTableAdapter();
defaultDataSetTableAdapters.customersTableAdapter customerQueryTable = new defaultDataSetTableAdapters.customersTableAdapter();

protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToString(Session["userIsAdmin"]) == "False")
    {
        configControls.Visible = false;
        employeesDisplayTable.Columns[4].Visible = false;
        customersDisplayTable.Columns[3].Visible = false;
    }
    else
    {
        configControls.Visible = true;
        employeesDisplayTable.Columns[4].Visible = true;
        customersDisplayTable.Columns[3].Visible = true;
    }
}

private string username;

protected void employeesDisplayTable_RowCommand(object sender, GridViewCommandEventArgs e)
{
    username = employeesDisplayTable.Rows[Convert.ToInt32(e.CommandArgument)].Cells[0].Text;
    switch (e.CommandName)
    {
        case "deleteUser":
            if (username == "master")
            {
                returnLabel.Text = "You can't delete the master admin account!";
                deletingUsersPersistent.deleting = false;
                deletingUsersPersistent.type = "";
                break;
            }
            deleteUser(username, "Employee");
            break;
        case "changeUserPassword":
            changeUserPassword(username, "Employee");
            break;
    }
}

protected void customersDisplayTable_RowCommand(object sender, GridViewCommandEventArgs e)
{
    username = customersDisplayTable.Rows[Convert.ToInt32(e.CommandArgument)].Cells[0].Text;
    switch (e.CommandName)
    {
        case "deleteUser":
            deleteUser(username, "Customer");
            break;
        case "changeUserPassword":
            changeUserPassword(username, "Customer");
            break;
    }
}

static class deletingUsersPersistent
{
    public static string username;
    public static bool deleting;
    public static string type;
}

protected void deleteUser(string username, string type)
{
    GridView displayTable;
    if (type == "Employee")
    {
        displayTable = employeesDisplayTable;
    }
    else if (type == "Customer")
    {
        displayTable = customersDisplayTable;
    }
    else
    {
        throw new Exception();
    }

    if ((deletingUsersPersistent.deleting) && (username == deletingUsersPersistent.username) && deletingUsersPersistent.type == type)
    {
        returnLabel.Text = type + " account " + deletingUsersPersistent.username + " was deleted";
        deletingUsersPersistent.deleting = false;
        deletingUsersPersistent.type = "";
        if (type == "Employee")
        {
            employeeQueryTable.deleteUser(username);
        }
        else
        {
            customerQueryTable.deleteUser(username);
        }
        customLogging.newEntry(type + " " + username + " was deleted");
        displayTable.DataBind();
        System.Threading.Thread.Sleep(750);
        returnLabel.Text = "";
    }
    else
    {
        returnLabel.Text = "Click again to delete - note that this cannot be undone!";
        deletingUsersPersistent.deleting = true;
        deletingUsersPersistent.username = username;
        deletingUsersPersistent.type = type;
    }
}

protected void changeUserPassword(string username, string type)
{
    GridView displayTable;
    if (type == "Employee")
    {
        displayTable = employeesDisplayTable;
    }
    else if (type == "Customer")
    {
        displayTable = employeesDisplayTable;
    }
    else
    {
        throw new Exception();
    }

    returnLabel.Text = "";
    deletingUsersPersistent.deleting = false;
    if (customSecurity.sanitizeCheck(new string[] { passwordBox.Text }))
    {
        if (passwordBox.Text != "" || confirmPassword.Text != "")
        {
            if (passwordBox.Text == confirmPassword.Text)
            {
                if (type == "Employee")
                {
                    employeeQueryTable.changePassword(customSecurity.generateMD5(passwordBox.Text), username);
                }
                else
                {
                    customerQueryTable.changePassword(customSecurity.generateMD5(passwordBox.Text), username);
                }
                customLogging.newEntry(type + " " + username + "'s password changed");
                returnLabel.Text = type + " " + username + "'s password was changed to '" + passwordBox.Text + "'.";
            }
            else
            {
                returnLabel.Text = "The passwords do not match!";
                System.Threading.Thread.Sleep(750);
                returnLabel.Text = "";
            }
        }
        else
        {
            returnLabel.Text = "You must fill both boxes!";
            System.Threading.Thread.Sleep(750);
            returnLabel.Text = "";
        }
    }
    else
    {
        returnLabel.Text = customSecurity.sanitizeErrorMessage;
    }
}

protected void registerRedirect_Click(object sender, EventArgs e)
{
    Server.Transfer("~/registerEmployee.aspx", false);
}

protected void newCustomerButton_Click(object sender, EventArgs e)
{
    Server.Transfer("~/registerCustomer.aspx", false);
}
    \end{lstlisting}
    \paragraph{The Page}
    On this page, there are two ASP.NET GridView elements.
    These are rendered tables which show the contents of a databound source on the page.
    Many different types of databound sources exist but the one I am using for both these GridViews is my database.
    \paragraph{}
    The first GridView is linked to the employees table, and shows usernames, full names and whether they are an administrator or not.
    Additionally, it has a column that contains two buttons in each row; one is the delete button for that account and the other will change the password.
    These buttons have the username of the employee row they are on bound to them as a command argument, and are linked with an eventhandler automatically to the same method.
    The CommandName attribute of each is how they much be differentiated between, they are set to "deleteUser" and "changeUserPassword" respectively.
    Following this GridView is a button which simply redirects to the employee registration page.
    \paragraph{}
    The other GridView is linked to the customers table.
    It shows the customers' usernames and full names in addition an identical set of buttons to those described above, which are both bound to a different method.
    Underneath the GridView is a button which redirects to the customer registration page.
    \paragraph{}
    Below these controls are two text boxes where the administrator can enter the password they wish to change an account's to; the extra one is for confirmation.
    Finally, there is a label to return messages to the user.
    Ultimately, the page looks like this:
    \begin{figure}[h]
        \includegraphics{userConfigPage.png}
        \centering
    \end{figure}
    \paragraph{The Code}
    The properties and variables on this page are:
    \begin{itemize}
        \item \textbf{employeeQueryTable} is an adaptor for the queries registered to the employee table.
        \item \textbf{customerQueryTable} is an adaptor for the queries registered to the customer table.
        \item \textbf{username} is a string to hold the username of the username in question between methods.
        \item \textbf{deletingUsersPersistent} is a static class which holds the information about users between executions of the method which carries it out.
        Since I wanted the additional security against user mistakes of making them click the button to delete twice, the method must be executed twice and be aware when it is being executed a second time in a row.
        Hence, I created a static class which cannot be instantiated, only referred to, to hold information that would inform that method.
        It holds the username and the type of the user in question and a bool that determines whether they are on their "second click".
    \end{itemize}
    The methods on the page are:
    \begin{itemize}
        \item \textbf{Page\_Load} in this instance determines whether or not to show the controls for changing and deleting accounts.
        If the user is marked as an admin by the "userIsAdmin" session, then the columns containing the buttons and the elements at the bottom of the page (which are in a panel called "configControls") are set to be visible.
        If not, they are set to be invisible.
        \item \textbf{employeesDisplayTable\_RowCommand} is called when a RowCommand is triggered on the GridView showing employees.
        This only occurs when one of the buttons within the table is clicked.
        First, the method gets the username of the user the command is called upon; it does this by taking the CommandArgument of the button and using it as the index of a row in the GridView, then finding the value stored in the first cell (the username cell).
        It then uses a switch to determine which button was clicked according to it's CommandName.
        If the user is trying to delete an employee, the methods checks with an if statement if they are trying to delete the master account by examining the username variable previously set - if they are, they are informed with the return label that they cannot and the deletingUsersPersistent class is reset to it's default state.
        If not, deleteUser() is run.
        Should the user be trying to change a password, the switch runs changeUserPassword with the correct parameters.
        \item \textbf{customersDisplayTable\_RowCommand} is called when a RowCommand is triggered in the GridView corresponding to the customers table.
        It serves a similar purpose to "employeesDisplayTable\_RowCommand", pulling the username of the customer in question into "username" in exactly the same way as it does in the employees GridView.
        A similar switch is run, but there is no check for sensitive usernames.
        \item \textbf{deleteUser} is called by both RowCommand methods when the user is trying to delete an account.
        It determines which type of user to delete with the parameters it is passed, which should only be "Employee" or "Customer" - if they aren't, a new exception is thrown.
        \\
        An if statement determines if the user is clicking the delete button for the first time or the second.
        This is checked by examining the values of the deleting, username and type properties of deletingUsersPersistent - if they match the current conditions, code is run to delete the account.
        If not, the return label shows a warning that the user is about to delete an account if they click a second time.
        The contents of deletingUsersPersistent are set to the current conditions.
        Should the user click a second time and start the account deletion process, the return label is updated with an appropriate message.
        The deletingUsersPersistent class is set to it's default state, and the relevant query is run.
        If an employee is being deleted, deleteUser is run from the correct adaptor:
        \begin{lstlisting}[language=SQL]
DELETE FROM `employees` WHERE ((`username` = ?))
        \end{lstlisting}
        If a customer is being deleted, deleteUser is run from the customer adaptor:
        \begin{lstlisting}[language=SQL]
DELETE FROM `customers` WHERE ((`username` = ?))
        \end{lstlisting}
        Both of these queries are run using the username in deletingUsersPersistent.
        The deletion is logged, the table is refreshed using DataBind(), a pause is initiated and the message is cleared.
        \item \textbf{changeUserPassword} runs when either RowCommand calls it.
        Similarly to deleteUser, it finds the correct GridView with the parameter it is passed.
        The contents of the return label is cleared, and deletingUsersPersistent.deleting is set to false so one cannot click to delete someone, click change password then click to delete that person again and actually delete them without warning.
        Then, a series of checks are performed:
        \begin{enumerate}
            \item customSecurity.sanitizeCheck is called on both password boxes and the standard error displayed if the check is failed.
            \item Both password boxes are confirmed to actually contain text
            \item The password boxes' contents are confirmed to match
        \end{enumerate}
        The appropriate query is run.
        If an employee is the subject of the change, changePassword is run from the employees query table:
        \begin{lstlisting}[language=SQL]
UPDATE employees
SET [password] = ?
WHERE (username = ?)
        \end{lstlisting}
        If a customer is the subject of the password change, changePassword is run from the customers tables adaptor:
        \begin{lstlisting}[language=SQL]
UPDATE customers
SET [password] = ?
WHERE (username = ?)
        \end{lstlisting}
        The change is logged and the return label is updated with the appropriate text.
        \item \textbf{registerRedirect\_Click} and \textbf{newCustomerButton\_Click} redirect to the employee and customer registration pages respectively.
    \end{itemize}
    \paragraph{Revision 05/05/18}
    This code is extremely messy.
    I have made multiple changes:
    \begin{enumerate}
        \item I have made the "type" variable passed into deleteUser and changeUserPassword an enumerator, which means the two options are enforced and a switch can be used in each:
        \begin{lstlisting}[language=C]
private enum userType { employee,customer }
        \end{lstlisting}
        And changed the contents of both mentioned methods appropriately, at the beginning where a reference to the appropriate GridView is set:
        \begin{lstlisting}[language=C]
GridView displayTable;
switch (type)
{
    case userType.customer:
        displayTable = customersDisplayTable;
        break;
    case userType.employee:
        displayTable = employeesDisplayTable;
        break;
    default:
        throw new Exception();
}
        \end{lstlisting}
        Ideally, the default case would not be there but later code throws a build error citing that displayTable isn't assigned to (even though this is impossible) if it isn't.
        \item Removed unnecessary sleep times.
        Initially I inserted these so I could clear error messages after a certain time but this is unnecessary and not in keeping with the rest of the application.
        \item I have, as in other places, reorganised the horrendously eye watering set of nested if statements inside changeUserPassword into a sequence of if statements which will disqualify the operation if triggered:
        \begin{lstlisting}[language=C]
GridView displayTable;
switch (type)
{
    case userType.customer:
        displayTable = customersDisplayTable;
        break;
    case userType.employee:
        displayTable = employeesDisplayTable;
        break;
    default:
        throw new Exception();
}

returnLabel.Text = "";
deletingUsersPersistent.deleting = false;

if (passwordBox.Text == "" || confirmPassword.Text == "")
{
    returnLabel.Text = "You must fill both boxes!";
    return;
}

if (passwordBox.Text != confirmPassword.Text)
{
    returnLabel.Text = "The passwords do not match!";
    return;
}

if (type == userType.employee)
{
    employeeQueryTable.changePassword(customSecurity.generateMD5(passwordBox.Text), username);
}
else
{
    customerQueryTable.changePassword(customSecurity.generateMD5(passwordBox.Text), username);
}
customLogging.newEntry(type + " " + username + "'s password changed");
returnLabel.Text = type + " " + username + "'s password was changed to '" + passwordBox.Text + "'.";
        \end{lstlisting}
        \item I have added "Market" to the reserved usernames check in deleteUser and updated the error message:
        \begin{lstlisting}[language=C]
if (username == "master" || username == "Market")
{
    returnLabel.Text = "You can't delete this account!";
    deletingUsersPersistent.deleting = false;
    deletingUsersPersistent.type = userType.customer;
    break;
}
        \end{lstlisting}
    \end{enumerate}
    \newpage
    \subsubsection{Product Management/Configuration}
    The product management page allows employees to create new products and edit the stock and prices of existing ones.
    \begin{lstlisting}[language=C]
private defaultDataSetTableAdapters.productsTableAdapter productQueryTable = new defaultDataSetTableAdapters.productsTableAdapter();

protected void Page_Load(object sender, EventArgs e)
{

}

protected void productsTable_RowCommand(object sender, GridViewCommandEventArgs e)
{
    if(e.CommandName != "deleteProduct")
    {
        return;
    }
    string productName = productsTable.Rows[Convert.ToInt32(e.CommandArgument)].Cells[0].Text;
    if ((deletingProductsPersistent.deleting) && (productName == deletingProductsPersistent.product))
    {
        returnLabel.Text = "Product " + productName + " was deleted";
        System.IO.File.Delete(Server.MapPath("~/images/") + productName);
        using (var cartsAdaptor = new defaultDataSetTableAdapters.cartsTableAdapter())
        {
            cartsAdaptor.deleteProducts(productName);
        }
        using (var marketAdaptor = new defaultDataSetTableAdapters.marketTableAdapter())
        {
            marketAdaptor.deleteProducts(productName);
        }
        using (var ordersAdaptor = new defaultDataSetTableAdapters.ordersTableAdapter())
        {
            ordersAdaptor.removeProducts(productName);
        }
        productQueryTable.deleteProduct(productName);
        returnLabel.Text = "Product deleted";
        customLogging.newEntry("The product " + productName + " was deleted");
        productsTable.DataBind();
        System.Threading.Thread.Sleep(2000);
        returnLabel.Text = "";
    }
    else
    {
        returnLabel.Text = "Click again to delete - note that this cannot be undone!";
        deletingProductsPersistent.deleting = true;
        deletingProductsPersistent.product = productName;
    }
}

protected void productAddButton_Click(object sender, EventArgs e)
{
    do
    {
        string errorAppend = "";

        if (customSecurity.sanitizeCheck(new string[] { productNameBox.Text, productPrice.Text, bandBox.Text, descriptionBox.Text }) != true)
        {
            returnMessage.Text = customSecurity.sanitizeErrorMessage;
            break;
        }

        string displayName = productNameBox.Text;
        string productName = displayName;
        string imagePath;
        TextInfo cultInfo = new CultureInfo("en-US", false).TextInfo;
        productName = cultInfo.ToTitleCase(productName);
        productName = productName.Replace(" ", "");
        productName = char.ToLower(productName[0]) + productName.Substring(1);
        if (productName.All(Char.IsLetterOrDigit) == false)
        {
            returnMessage.Text = "Please only use numbers and letters in the product name!";
            break;
        }

        if (!priceValid(productPrice.Text))
        {
            returnMessage.Text = "Invalid price format";
            break;
        }
        decimal price = Convert.ToDecimal(productPrice.Text);

        if (imageUpload.HasFile)
        {
            if (imageUpload.FileName.Substring(imageUpload.FileName.IndexOf(".")) != "png")
            {
                returnMessage.Text = "The image must be a PNG!";
            }
            try
            {
                string fileName = imageUpload.FileName;
                imagePath = "~/images/" + fileName;
                imageUpload.SaveAs(Server.MapPath(imagePath)); 
            }
            catch (Exception except)
            {
                returnMessage.Text = "File Upload failed with error " + except.Message + ", please contact a developer";
                return;
            }
        }
        else
        {
            errorAppend = " with no image";
            imagePath = "NONE";
        }

        returnMessage.Text = "Product created named " + productName + ", priced at £" + common.formatPrice(price) + " and displayed as " + displayName + errorAppend;
        productQueryTable.newProduct(productName, 0, Convert.ToDecimal(price), displayName, typeDropdown.SelectedValue, Convert.ToString(Session["currentUser"]), imagePath, bandBox.Text, descriptionBox.Text);
        customLogging.newEntry("The product " + productName + " was created");
        productsTable.DataBind();
    } while (false);
}

private static bool priceValid(string input)
{
    string noPoint = input.Replace(".", "");
    foreach (char c in noPoint)
    {
        if (!char.IsDigit(c))
        {
            return false;
        }
    }
    try
    {
        string decimalPlaces = input.Substring(input.IndexOf('.') + 1);
        if (decimalPlaces.Length > 2)
        {
            return false;
        }
        return true;
    }
    catch
    {
        return true;
    }
}

static class deletingProductsPersistent
{
    public static string product;
    public static bool deleting;
}
    \end{lstlisting}
    \paragraph{The Page}
    The page contains a single GridView, which is marked as editable.
    This means a small button appears at the side which, when clicked, allows the user to change the stock and price values of a product:
    \begin{figure}[h]
        \includegraphics{productsConfigTable.png}
        \centering
    \end{figure}
    \begin{figure}[h]
        \includegraphics{productsConfigEditing.png}
        \centering
    \end{figure}
    Additionally, the page contains a set of controls forming a form for adding products.
    These are mostly textboxes, with an image upload dialog and a dropdown to dictate whether the product is an image or a clock.
    \begin{figure}[h]
        \includegraphics{productForm.png}
        \centering
    \end{figure}
    \paragraph{The Code}
    The only properties on this page are:
    \begin{itemize}
        \item \textbf{productQueryTable}, which is a loval instance of the table adaptor for queries on the product table.
        \item \textbf{deletingProductsPersistent} is a static class which serves an identical purpose as the one in the user configuration page.
        It enables the "click twice to delete" functionality.
    \end{itemize}
    I have declared it in the root of the class because it is used in multiple methods.
    The methods in the code are as follows:
    \begin{itemize}
        \item \textbf{Page\_Load} does not serve any purpose on this page.
        \item \textbf{productsTable\_RowCommand}, like on the users configuration page, is called when a button is pressed inside a template field (ie. button column) in the GridView on the page (called productsTable).
        It starts with an if statement checking if the command name is not "deleteProduct" - this is needed because this table is set to be editable; when the edit button is pressed, this method is run as part of the function of the Edit button but because I have added custom code to it, it would run that code and delete the product if the button were pressed twice - this if statement prevents that from executing if the command is not labelled as a delete command.
        It does not need to check anything else about the RowCommand because it will only be executed intentionally when the user wants to delete a product.
        \\
        The method gets the name of the product in question using the CommandArgument of the RowCommand (which is set to be the index of the row of the table in the ASP code) as the index of a row, and getting the value of the first cell of that row.
        In this cell will be the product name, as it is laid out in the table.
        Before deletion commences, the deleting and product attributes of deletingProductsPersistent are checked to ensure this is the second click on the delete button.
        If they aren't as expected, then they are set to the current conditions, and an appropriate message is shown to the user.
        The method is ended.
        \\
        The first step of the deletion is to run System.IO.File.Delete to remove the image of the product from the directory it's in; the directory is obtained by using Server.MapPath to get the actual path of the "~/images" folder and appending it with the name of the product so it points to a specific file.
        Three queries are then run to keep referential integrity of the database enforced:
        \begin{enumerate}
            \item cartsAdaptor.deleteProducts removes all the instances of the product which is being deleted from user carts.
            This also ensures users cannot purchase products which no longer exist.
            \begin{lstlisting}[language=SQL]
DELETE FROM carts
WHERE (productName = ?)
            \end{lstlisting}
            \item marketAdaptor.deleteProducts removes all instances of the product being deleted from the physical markets records.
            This step is not strictly necessary as the client should enforce this in the real world before deleting the product from the application, but it still enforces referential integrity.
            Since the client should do this, problems shouldn't arise with products which are still on sale being deleted.
            \begin{lstlisting}[language=SQL]
DELETE FROM market
WHERE (productName = ?)
            \end{lstlisting}
            \item ordersAdaptor.removeProducts removes all instances of the product from the orders table.
            This is not a good solution to this problem: the integrity of the database's references must be enforced but deleting past orders sabotages data and will show inconsistencies in sales.
            Therefore, this needs revision which I will address later.
            \begin{lstlisting}[language=SQL]
DELETE FROM orders
WHERE (product = ?)
            \end{lstlisting}
        \end{enumerate}
        The final query productQueryTable.deleteProduct deletes the product itself from the products table:
        \begin{lstlisting}[language=SQL]
DELETE FROM `products`
WHERE ((`productName` = ?))
        \end{lstlisting}
        The return label is updated appropriately and the deletion is logged.
        productsTable.DataBind is run to refresh the contents of productsTable to show the deletion.
        \item \textbf{productAddButton\_Click} is run when the add button is clicked.
        It consists of a do loop which is ended with a "while (false)", meaning it will only be run once.
        I did this because it allows me to perform checks and break the loop if any of them fail.
        A string called errorAppend is initialized to contain any extensions to log messages.
        The first check is customSecurity.sanitizeCheck, as with all database-related operations in the application.
        If it is failed it, as usual, displays the standard error message and breaks the loop.
        The needed variables are declared (displayName, productName and imagePath).
        displayName and productName are both set to the contents of the product name textbox.
        \\
        In order to convert the displayName to camel case to be used as the product name, a new variable of type TextInfo is created, called "cultInfo" and assigned as the TextInfo property of a CultureInfo for english.
        This variable can recognize space-separated words in a string and uses this in the ToTitleCase method I call; thus capitalising the first letters of all the words in the product name.
        Next, spaces are removed and char.ToLower is called on the first character of the string to make it lowercase.
        All the characters in productName are check to be letters or digits with the IsLetterOrDigit method of the Char class.
        If any of them aren't, the user is notified and the operation broken.
        priceValid is run on the price box to ensure it is in the appropriate format for the price.
        The price variable is set to the value of the price box.
        The uploaded image is checked in multiple ways:
        \begin{enumerate}
            \item If there isn't a file selected in the dialog, set the image path as being "NONE" and errorAppend is set to " with no image" so that the log will reflect this.
            \item If the image given isn't a PNG file, the page rejects the image and notifies the user.
            \item The image is attempted to be uploaded.
            This portion of the code is enclosed in a try - catch statement because I have little experience with image management in .NET and so am expecting errors during development.
        \end{enumerate}
        The image is uploaded by getting the file name of the image and appending it to "~/images" so when it is displayed the control looks in the images folder in the root directory.
        Finally, the image is actually saved using the SaveAs method of the image upload dialog; the path it is given is generated by giving the image path variable to the method Server.MapPath which will return a full directory string for the image.
        \\
        The return label is updated to inform the user that the operation was successful, and a query is run to store the products and all it's information in the database:
        \begin{lstlisting}[language=SQL]
INSERT INTO products
(productName, stock, price, displayName, productType, creator, [image], [band], description)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        \end{lstlisting}
        The creation is logged and productsTable is refreshed with DataBind to reflect the creation.
        \item \textbf{priceValid} exists to check if the given number is valud as a price in GBP.
        A variable is created which holds the price without the decimal point to check if it is all digits, which is carried out for each character in the string using char.IsDigit().
        If this check or any other is failed, "false" is returned.
        The digits left of "." are obtained using substring, and the length of the resulting string is checked.
        If there are more than 2, the check is failed.
        If there aren't any, an exception will be thrown which will be caught by the try catch statement and true will be returned.
        If all these checks are passed, true is returned.
    \end{itemize}
    \paragraph{Revision 21/04/18}
    I have made some changes to the code:
    \begin{enumerate}
        \item I have removed the do-while loop in productAddButton\_Click and replaced all the break statements with return.
        This solution was essentially redundant as the whole code block was encompassed in a method which could just be broken with "return".
        \begin{lstlisting}[language=C]
string errorAppend = "";

if (customSecurity.sanitizeCheck(new string[] { productNameBox.Text, productPrice.Text, bandBox.Text, descriptionBox.Text }) != true)
{
    returnMessage.Text = customSecurity.sanitizeErrorMessage;
    return;
}

string displayName = productNameBox.Text;
string productName = displayName;
string imagePath;
TextInfo cultInfo = new CultureInfo("en-US", false).TextInfo;
productName = cultInfo.ToTitleCase(productName);
productName = productName.Replace(" ", "");
productName = char.ToLower(productName[0]) + productName.Substring(1);
if (productName.All(Char.IsLetterOrDigit) == false)
{
    returnMessage.Text = "Please only use numbers and letters in the product name!";
    return;
}

if (!priceValid(productPrice.Text))
{
    returnMessage.Text = "Invalid price format";
    return;
}
decimal price = Convert.ToDecimal(productPrice.Text);

if (imageUpload.HasFile)
{
    if (imageUpload.FileName.Substring(imageUpload.FileName.IndexOf(".")) != "png")
    {
        returnMessage.Text = "The image must be a PNG!";
        return;
    }
    try
    {
        string fileName = imageUpload.FileName;
        imagePath = "~/images/" + fileName;
        imageUpload.SaveAs(Server.MapPath(imagePath)); 
    }
    catch (Exception except)
    {
        returnMessage.Text = "File Upload failed with error " + except.Message + ", please contact a developer";
        return;
    }
}
else
{
    errorAppend = " with no image";
    imagePath = "NONE";
}

returnMessage.Text = "Product created named " + productName + ", priced at £" + common.formatPrice(price) + " and displayed as " + displayName + errorAppend;
productQueryTable.newProduct(productName, 0, Convert.ToDecimal(price), displayName, typeDropdown.SelectedValue, Convert.ToString(Session["currentUser"]), imagePath, bandBox.Text, descriptionBox.Text);
customLogging.newEntry("The product " + productName + " was created");
productsTable.DataBind();
        \end{lstlisting}
        \item Replaced the foreach loop in priceValid with a .All function so that less iteration is needed:
        \begin{lstlisting}[language=C]
if(!noPoint.All(Char.IsDigit))
{
    return false;
}
        \end{lstlisting}
    \end{enumerate}
    \newpage
    \subsubsection{Market}
    The market page is used by employees to manage what products they are taking to physical markets.
    The page inherits from Employee.Master and therefore is inaccessible by ordinary users.
    \begin{lstlisting}[language=C]
defaultDataSetTableAdapters.marketTableAdapter adaptor = new defaultDataSetTableAdapters.marketTableAdapter();

public static marketItem[] takingItems = new marketItem[0];
public static productList productsList;

protected void Page_Load(object sender, EventArgs e)
{
    if (Convert.ToInt32(Session["marketInitialized"]) == 1)
    {
        populatePage();
    }
    else
    {
        productsList = new productList();
        takingItems = new marketItem[0];
        populatePage();
        Session["marketInitialized"] = 1;
    }
}

private void populatePage()
{
    populateMainPanel();
    populateTakingPanel();
}

private void populateMainPanel()
{
    var controlSet = productsList.generateControls();
    productsListPanel.Controls.Clear();
    int i = 0;
    foreach (productPanel current in controlSet)
    {
        Button addToStall = new Button()
        {
            ID = productsList.list[i].productName + "AddToStall",
            Text = "Add",
            CommandArgument = productsList.list[i].productName
        };
        addToStall.Click += new EventHandler(addToStall_Click);
        addToStall.Attributes.Add("runat", "server");
        current.Controls.Add(addToStall);
        productsListPanel.Controls.Add(current);
        i++;
    }
}

private void populateTakingPanel()
{
    var data = adaptor.getStallItems(Convert.ToString(Session["currentUser"]));
    List<marketItem> tempList = new List<marketItem>();
    foreach (DataRow current in data)
    {
        marketItem tempItem = new marketItem();
        tempItem.product = new product(Convert.ToString(current[1]));
        tempItem.amount = Convert.ToInt32(current[2]);
        tempList.Add(tempItem);
    }
    takingItems = common.appendArray(takingItems, tempList.ToArray());
    generateTakingControls();
}

private void generateTakingControls()
{
    takingPanel.Controls.Clear();
    foreach (marketItem current in takingItems)
    {
        productPanel panel = new productPanel(current.product);
        panel.ID = panel.ID + "Taking";
        foreach (Control currentControl in panel.Controls)
        {
            if (currentControl.ID != "" && currentControl.ID != null)
            {
                currentControl.ID = currentControl.ID + "Taking";
            }
        }
        foreach (Control currentControl in panel.Controls[1].Controls)
        {
            if (currentControl.ID != "" && currentControl.ID != null)
            {
                currentControl.ID = currentControl.ID + "Taking";
            }
        }
        TextBox amountBox = new TextBox()
        {
            ID = current.product.productName + "_AmountBox",
            CssClass = "marketAmountBox",
            Text = Convert.ToString(current.amount)
        };
        amountBox.TextChanged += new EventHandler(amountBox_TextChanged);
        amountBox.Attributes.Add("runat", "server");
        panel.Controls.Add(amountBox);
        takingPanel.Controls.Add(panel);
    }
}

private void addToStall_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    bool existing = false;
    foreach (marketItem current in takingItems)
    {
        if (current.product.productName == btn.CommandArgument)
        {
            existing = true;
        }
    }
    if (existing)
    {
        returnLabel.Text = "You've already got that product in your taking list, please update it's amount or remove it!";
    }
    else
    {
        marketItem newItem = new marketItem();
        newItem.amount = 1;
        newItem.product = new product(btn.CommandArgument);
        takingItems = common.appendArray(takingItems, newItem);
        generateTakingControls();
    }
}

private void amountBox_TextChanged(object sender, EventArgs e)
{
    TextBox box = (TextBox)sender;
    string productName = box.ID.Split('_')[0];
    int index = 0;
    foreach (marketItem current in takingItems)
    {
        if (current.product.productName == productName)
        {
            break;
        }
        index++;
    }
    takingItems[index].amount = Convert.ToInt32(box.Text);
}

protected void applyButton_Click(object sender, EventArgs e)
{
    defaultDataSetTableAdapters.productsTableAdapter productsAdaptor = new defaultDataSetTableAdapters.productsTableAdapter();
    foreach (marketItem current in takingItems)
    {
        int currentStock = Convert.ToInt32(productsAdaptor.getStock(current.product.productName));
        if (currentStock < current.amount)
        {
            returnLabel.Text = "Sorry, we only have " + currentStock + " of " + current.product.productName;
            return;
        }
    }
    adaptor.deleteStall(Convert.ToString(Session["currentUser"]));
    foreach (marketItem current in takingItems)
    {
        adaptor.newStallItem(current.product.productName, current.amount, Convert.ToString(Session["currentUser"]));
        productsAdaptor.updateStock(Convert.ToInt32(productsAdaptor.getStock(current.product.productName)) - current.amount, current.product.productName);
    }
    returnLabel.Text = "Changes successfully applied";
    populatePage();
}

protected void endStallButton_Click(object sender, EventArgs e)
{
    Server.Transfer("~/marketEnd.aspx", false);
}

public struct marketItem
{
    public product product;
    public int amount;
}
    \end{lstlisting}
    \paragraph{The Page}
    The page holds two panels for products.
    The first is for an exhaustive list of all the products in the database (productsListPanel), the second is for a list of all the products the employee has selected to take with them to the market (takingPanel).
    Furthermore, there are two buttons to apply the changes to the market and to end the stall and record sales made.
    As usual, a return label is included.
    \paragraph{The Code}
    The properties and variables on this page are:
    \begin{itemize}
        \item \textbf{adaptor} is a instance of the market table query adaptor.
        \item \textbf{marketItem} is a custom structure designed to allow a list of products to be made with amounts attached.
        It is functionally identical to cartItem, having product "product" and integer "amount" properties.
        \item \textbf{takingItems} is an array of marketItem which represents all the items the user is taking with them on the physical market.
        It is initialized as an empty array so that AppendArray can be run on it.
        \item \textbf{productsList} is a vanilla instance of productList to display all the items in the database.
    \end{itemize}
    The methods in the code are:
    \begin{itemize}
        \item \textbf{Page\_Load} here checks if the market has been initialized with the unique session "marketInitialized", stored as a 1 or a 0.
        If it has already been initialized, only populatePage is run to save processing power and time.
        If not, productsList is initialized as a vanilla productList and takingItems is initialized as a blank array of marketItems.
        populatePage is run and the session is set to "1" to indicate that the page has been initialized already.
        \item \textbf{populatePage} is essentially just a method to bind together populateMainPanel and populateTakingPanel.
        It simply runs them both.
        \item \textbf{populateMainPanel} fills the panel which should show all the available items in the first panel on the page.
        It creates a variable with the context-sensitive keyword "var" to hold all the panels generated by productsList.generateControls then clears the controls which are already in the panel on the page.
        A foreach loop is run with an external index tracked to run through all the productPanels in the controlSet variable described above.
        A new button is made, given a unique ID generated with the product's name, labelled with "Add" and given a CommandArgument of the product's name.
        A new EventHandler is initialized and assigned to the new button to run "addToStall\_Click" when the button is clicked.
        The "runat:server" attribute is added so the button functions correctly and the button is added to the current productPanel.
        The current productPanel is added to the controls list of the panel waiting for it on the page with Controls.Add.
        This process is repeated for all productPanels in the array.
        \item \textbf{populateTakingPanel} fills the second panel with all the items the user is taking.
        It runs the getStallItems query into the variable data (a DataTable):
        \begin{lstlisting}[language=SQL]
SELECT productName, amount
FROM market
WHERE (employee = ?)
        \end{lstlisting}
        To obtain all the items the current employee is taking to market.
        It creates a new list called "tempList" to hold all the items after they are processed.
        A foreach loop is run for each row in the DataTable (ie. each type of item the employee is taking)
        Within the loop, a new marketItem is instantiated, it's product property set to a new product instance generated using the name of the product gotten from the first cell in the row, it's amount set with the second cell in the row and it is added to the temporary list of marketItems.
        The contents of tempList are appended to the existing takingItems array, and generateTakingControls is run.
        \item \textbf{generateTakingControls} creates all the controls and productPanels needed to show in the bottom panel to display what the user is taking with them to market.
        It starts by clearing the existing controls out of the panel to start with a clean slate, and runs through each item in takingItems.
        A new productPanel is instantiated and "Taking" appended to it's ID.
        All of the controls within that productPanel have their IDs appended with this so that ASP.NET doesn't throw exceptions based on different things having the same IDs (which will happen otherwise since we are making new copies of productPanels to add to the bottom main panel which would otherwise be entirely identical (in terms of IDs) to those in the top).
        Foreach loops are used for this purpose.
        The first foreach loop runs through all the controls in the whole panel and appends all those whose IDs aren't blank with "Taking".
        The second foreach loop runs through all the controls in the textWrapper panel within the productPanel (control index 1) and does exactly the same thing.
        \\
        A new textbox is created and it's ID generated with the name of the product appended with "\_AmountBox"; the underscore is there so the the product the textbox refers to can be easily identified in "amountBox\_TextChanged".
        \item \textbf{addToStall\_Click} runs when the add to stall button is clicked.
        It gets the button which called it by filtering it's sender by type button.
        It creates a boolean to determine whether or not the product the user is clicking on is already in their taking list and assigns it false by default.
        A foreach loop runs through each marketItem in takingItems and sets existing to true if any of their names match that of the product the user is trying to add.
        An if statement checks the boolean, cancels the operation and returns an error if the user is trying to add something they are already taking.
        If they are adding a new product, a new marketItem is initialized, it's amount set to 1 to start with and it's product set to a new instance of product generated with the correct name.
        takingItems is appended with the item, and generateTakingControls is run to reflect the addition.
        \item \textbf{amountBox\_TextChanged} runs when the return key is pressed within one of the amount text boxes for the products the user is taking with them.
        It gets the sender by filtering sender by type TextBox and gets the name of the product in question using the text before the underscore in it's ID.
        It uses a foreach loop with an externally managed index to find the relevant item in takingItems by breaking when it finds the correct marketItem.
        The amount property of the marketItem in takingItems at the index of the foreach loop when it broke is changed appropriately.
        \item \textbf{applyButton\_Click} runs when the apply button is clicked.
        It opens a new instance of the products table adaptor to run queries on that table from.
        A foreach loop runs through all the item types the user is taking and checks if the amounts are more than the available stock using getStock:
        \begin{lstlisting}[language=SQL]
SELECT stock
FROM products
WHERE (productName = ?)
        \end{lstlisting}
        If any of them are trying to take more than available then an error message is shown and the operation is cancelled before any changes are made.
        If not, the database table is cleared of the stall in order to readd it.
        This is a terrible method of updating the table, but at the time this code was written I was pressed for time.
        Another foreach loop is run through all the items in takingItems and for each one two queries are run; newStallItem on the market table to add the item back:
        \begin{lstlisting}[language=SQL]
INSERT INTO `market` (`productName`, `amount`, `employee`) VALUES (?, ?, ?)
        \end{lstlisting}
        And updateStock on the products table to subtract the amount the employee is taking from the current stock.
        \begin{lstlisting}[language=SQL]
UPDATE products
SET stock = ?
WHERE (productName = ?)
        \end{lstlisting}
        Finally, the return label is updated with an appropriate message and populatePage is run to reflect the changes.
        \item \textbf{endStallButton\_Click} runs whenm the button to end the stall is clicked.
        It redirects the user to marketEnd.aspx to manage the sales made.
    \end{itemize}
    \paragraph{Revision 01/05/18}
    I realised that the code checking the stock amount in applyButton\_Click wasn't performing the correct task.
    As-is, it was checking the amout against the non-reserved stock which meant it wasn't accounting for the stock already reserved in the table.
    I have amended the contents of the first foreach loop in that method to the following:
    \begin{lstlisting}[language=C]
int reserved = Convert.ToInt32(adaptor.getReserved(current.product.productName));
int currentStock = Convert.ToInt32(productsAdaptor.getStock(current.product.productName));
if (currentStock + reserved < current.amount)
{
    returnLabel.Text = "Sorry, we only have " + currentStock + " of " + current.product.productName;
    return;
}
    \end{lstlisting}
    The query "getReserved" contains:
    \begin{lstlisting}[language=SQL]
SELECT amount
FROM market
WHERE (productName = ?)
    \end{lstlisting}
    \newpage
    \subsubsection{Market End}
    Employees are taken here when they click the "End Stall" button on the market page.
    They enter the amount of each product they sold and record it with the button.
    The page inherits from Employee.Master so it is inaccessible to customers.
    \begin{lstlisting}[language=C]
protected struct marketItem
{
    public product product;
    public int amount;
}

marketItem[] takenItems = new marketItem[0];
defaultDataSetTableAdapters.marketTableAdapter marketAdaptor = new defaultDataSetTableAdapters.marketTableAdapter();

protected void Page_Load(object sender, EventArgs e)
{
    getTakingItems();
    drawControls();
}

protected void getTakingItems()
{
    var data = marketAdaptor.getStallItems(Convert.ToString(Session["currentUser"]));
    foreach (DataRow current in data)
    {
        var tempItem = new marketItem();
        tempItem.product = new product(Convert.ToString(current[0]));
        tempItem.amount = Convert.ToInt32(current[1]);
        takenItems = common.appendArray(takenItems, tempItem);
    }
}

protected void drawControls()
{
    foreach (marketItem current in takenItems)
    {
        productPanel panel = new productPanel(current.product);
        Label takenLabel = new Label()
        {
            ID = current.product.productName + "AmountTakenLabel",
            CssClass = "amountTakenLabel",
            Text = current.amount + " Taken"
        };
        takenLabel.Attributes.Add("runat", "server");
        panel.Controls[1].Controls.Add(takenLabel);
        TextBox amountSold = new TextBox()
        {
            ID = current.product.productName + "AmountSoldBox",
            CssClass = "amountSoldBox",
            TextMode = TextBoxMode.Number,
            Text = "0"
        };
        amountSold.Attributes.Add("runat", "server");
        panel.Controls[1].Controls.Add(amountSold);
        productsBox.Controls.Add(panel);
    }
}

protected void applyButton_Click(object sender, EventArgs e)
{
    //Create a soldItems array and populate it with the relevant data
    marketItem[] soldItems = new marketItem[takenItems.Length];
    for (int i = 0; i < takenItems.Length; i++)
    {
        soldItems[i].product = takenItems[i].product;
        TextBox amountBox = (TextBox)productsBox.Controls[i].FindControl(takenItems[i].product.productName + "AmountSoldBox");
        soldItems[i].amount = Convert.ToInt32(amountBox.Text);
        if (soldItems[i].amount > takenItems[i].amount)
        {
            returnLabel.Text = "You can't have sold more items than you took!";
            return;
        }
    }

    decimal profit = 0;
    int totalSold = 0;
    defaultDataSetTableAdapters.productsTableAdapter productsAdaptor = new defaultDataSetTableAdapters.productsTableAdapter();
    defaultDataSetTableAdapters.ordersTableAdapter ordersAdaptor = new defaultDataSetTableAdapters.ordersTableAdapter();
    for (int i = 0; i < takenItems.Length; i++)
    {
        string currentName = takenItems[i].product.productName;
        int stockChange = takenItems[i].amount - soldItems[i].amount;
        int currentStock = soldItems[i].product.stock;
        
        productsAdaptor.updateStock(currentStock + stockChange, currentName);

        decimal spent = soldItems[i].product.price * soldItems[i].amount;
        ordersAdaptor.newOrder(DateTime.Now, spent, soldItems[i].amount, "Market", soldItems[i].product.productName);

        marketAdaptor.removeListing(soldItems[i].product.productName, Convert.ToString(Session["currentUser"]));

        profit += spent;
        totalSold += soldItems[i].amount;
    }

    returnLabel.Text = "Congratulations on making " + profit + "!";
    customLogging.newEntry("Employee " + Convert.ToString(Session["currentUser"] + " sold " + totalSold + " products."));
    getTakingItems();
    drawControls();
}
    \end{lstlisting}
    \paragraph{The Page}
    The page contains a panel (productsBox) for holding all the productPanels the page generates, a button to finalize the stall sales and a return label for error messages.
    \paragraph{The Code}
    The properties and variables on this page are:
    \begin{itemize}
        \item \textbf{marketItem} is a direct clone of the marketItem present on the market page.
        \item \textbf{takenItems} is an array of marketItem to store all the items the users has taken out to market.
        It serves much the same purpose as the similar array on the market page.
        \item \textbf{marketAdaptor} is a local instance of the query table adaptor for the market table.
    \end{itemize}
    The methods on the page are:
    \begin{itemize}
        \item \textbf{Page\_Load} on this page just calls the loading methods, getTakingItems and drawControls.
        \item \textbf{getTakingItems} accesses the database to get all the items the employee has taken the market and populates takenItems.
        It uses the getStallItems query from the market table to get a DataTable containing all the items the employee has out, with the "currentUser" session as the query term.
        A foreach loop is run for every row in the datatable; it creates a temporary marketItem to create with the data in the row.
        The product property is set to a new product initialized with the value in the first cell (the name) and the amount is assigned to the 2nd cell of the row (the amount), then the item is added to the takenItems array.
        \item \textbf{drawControls} generates all the panels to show what the user has taken to market in the productsBox.
        It goes through each marketItem in takenItems and instantiates a new productPanel for each.
        A new label to show how many they originally took is created and the relevant properties set, the "runat:server" attribute assigned and added to the panel's textWrapper panel.
        A new textbox is created to allow the user to input how many of the item they sold, and the relevant properties of it set.
        The amount is set to 0 by default.
        The "runat:server" attribute is added to it and it is added to the panel.
        Finally, the whole panel is added to the productsBox.
        \item \textbf{applyButton\_Click} runs when the apply button is clicked.
        It stores all the new data in the database.
        First, it creates a new array of marketItem to represent the items which have been sold.
        It then populates this using a for loop which goes through all the items in takenItems and copies the product property across to the corresponding soldItem.
        The amountBox is retrieved by using Controls.FindControl and giving the expected ID of the textbox based on how the ID is assigned in drawControls.
        Using the text in the textbox, the amount of the soldItem is set.
        A check is performed for each one that the employee isn't claiming to have sold more items than they took out - if they are, they are informed so and the operation is cancelled by returning the method early.
        \\
        New variables to store the total profit and the number of products sold are declared.
        Adaptors are opened for the products table and the orders table.
        Another for loop is run which goes through all the items in soldItems and takenItems and performs the necessary database operations.
        The name of the product is pulled into a string for convenience, along with the change in stock (ie. the amount taken minus the amount sold) and the current stock is taken from the product property of the current soldItem.
        The updateStock query is run on the products table in order to add back any stock which wasn't sold.
        A decimal to represent how much was spent is created and set to the amount sold multiplied by the price of the product.
        The newOrder query is run to record the sale in the orders table.
        The customer column is set to "Market" to show that the sale was made at market (as shown before, no customers can be called "Market").
        The two variables created earlier are added to and the process repeats for the next item.
        \\
        When the for loop has finished running,the returnLabel is updated with a congratulatory message and the salse are logged.
        The methods getTakingItems and drawControls are run to refresh the page.
    \end{itemize}
    \section{Testing}
    \subsection{To Inform Development}
    \subsubsection{Employee Login}
    This page is relatively simple, and so I am expecting few problems.
    The master account exists by default, as I manually added it and it is designed so that it cannot be removed or changed without manual intervention.
    Once the project is complete, I will remove, disable or change the account's password.
    The testing is as follows:
    \begin{enumerate}
        \item \textbf{SQL Injection}.
        I tried a common SQL injection: "; DROP ALL TABLES; --" which would ordinarily delete all the tables in my database.
        The application rejects the ";" so no SQL injection will work here.
        Note that the yellow boxes indicate my browser has autofilled them according to my saved "master" and password combination.
        This does not compromise testing.
        \begin{figure}[h]
            \includegraphics[height=3.5cm]{testing/empLogin1.png}
            \centering
        \end{figure}
        \item \textbf{Logging in with incorrect credentials}.
        I attempted a multitude of situations:
        \begin{enumerate}
            \item Using an existing username with a bad password.
            \begin{figure}[H]
                \includegraphics[height=3.5cm]{testing/empLogin2.png}
                \centering
            \end{figure}
            \item Using a fictional username and password.
            Note that the password box is blank here as it should be because I am using a different username so my browser does not attempt to correct me.
            \begin{figure}[H]
                \includegraphics[height=3.5cm]{testing/empLogin3.png}
                \centering
            \end{figure}
            \item Leaving the password box blank with a known username.
            \begin{figure}[H]
                \includegraphics[height=3.5cm]{testing/empLogin4.png}
                \centering
            \end{figure}
            \item Leaving the password box blank with a fictional username.
            \begin{figure}[H]
                \includegraphics[height=3.5cm]{testing/empLogin5.png}
                \centering
            \end{figure}
            \item Leaving both boxes blank.
            \begin{figure}[H]
                \includegraphics[height=3.5cm]{testing/empLogin6.png}
                \centering
            \end{figure}
        \end{enumerate}
        \item \textbf{Correct Credentials}.
        This works as expected, redirecting me to the employee homepage.
    \end{enumerate}
    \subsubsection{Customer Login}
    This uses practically identical code to the employee login page, so I have kept testing brief.
    \begin{enumerate}
        \item \textbf{SQL Injection}.
        I used the same string "; DROP ALL TABLES; --" to test this.
        \begin{figure}[H]
            \includegraphics[height=3.5cm]{testing/cusLogin1.png}
            \centering
        \end{figure}
        \item \textbf{Incorrect Credentials}.
        I tried all three scenarios as shown in the testing of the employee login page, and got the same result each time:
        \begin{figure}[H]
            \includegraphics[height=3.5cm]{testing/cusLogin2.png}
            \centering
        \end{figure}
        \item \textbf{Correct Credentials}.
        I entered the sample customer credentials I created ("customer" and "password").
        The site behaved as expected, and redirected me to the default page.
    \end{enumerate}
    \subsubsection{Cart Page}
    The cart page employs a lot of untested logic, and so requires relatively extensive testing.
    \subsection{To Inform Evaluation}
    
    \section{Evaluation}
    \subsection{Testing}
    \subsection{Usability Features}
    \subsection{Evaluation}
    I think I have 
    \subsection{Maintenance}
\end{document}